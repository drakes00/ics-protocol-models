theory OPCUA_Secure_Channel
begin

section{* OPCUA_Secure_Channel *}

/*
 * Protocol:    OPCUA_Secure_Channel
 * Modeler:     Dreier Jannik, Maxime Puys and Pascal Lafourcade      
 * Date:        17 june 2016
 * Status:      OPCUA Open secure channel
 */

builtins: signing, asymmetric-encryption, hashing


/* Public keys generation */
rule genServerKey:
    [ Fr(~x) ]
    --[ ServerKey($S, pk(~x)) ]->
    [ !Ltk($S, ~x), Out(<$S, pk(~x)>)]


rule genClientKey:
    [ Fr(~x) ]
    --[ ClientKey($C, pk(~x)) ]->
    [ !Ltk($C, ~x), Out(<$C, pk(~x)>)]


/*
// No corruption for the moment.
rule corrupt:
    [ !Ltk($C, ~x) ]
    --[ Corrupt($C, pk(~x)) ]->
    [ Out(<$C, ~x>) ]
*/


/* C -> DE : GEReq */
rule Init:
let
    m = 'GEReq'
in
    [ ]
    --[ Init($C, $S) ]->
    [ Out(m) ]


/* DE  -> C : GERes, pk(S), None, SP, UP */
rule Resp_Init:
let
    m = 'GEReq'
    m2 = <'GERes', pk(~x), 'None', $SP, $UP>
in
    [ In(m), !Ltk($S, ~x) ]
    --[ Resp($C, $S) ]->
    [ Out(m2) ]


/* C -> S : pk(C), <OSCReq, pk(C), Nc> */
/* Where Nc is a fresh nonce generated by C */
rule Resp_Client:
let
    m = <'GERes', keyS, 'None', sp, up>
    m2 = <pk(~x), 'OSCReq', pk(~x), ~nc>
in
    [ In(m), !Ltk($C, ~x), Fr(~nc) ]
    --[ Resp_Client($C, $S, ~nc, keyS, pk(~x)), WitnessNc($C, $S, ~nc) ]->
    [ Out(m2) ]


/* SE -> C : <OSCRes, NS , ST, TTL> */
rule Resp_Server:
let
    m = <keyC, 'OSCReq', keyC, nc>
    m2 = <pk(~x), 'OSCRes', ~ns, $ST, $TTL>
in
    [ !Ltk($S, ~x), In(m), Fr(~ns)]
    --[ Resp_Server($C, $S, ~ns, keyC, pk(~x)), RequestNc($C, $S, nc), WitnessNs($S, $C, ~ns) ]->
    [ Out(m2) ]


/* Client authenticates server on Ns */
rule Auth_Client:
let
    m = <keys, 'OSCRes', ns, st, ttl>
in
    [ In(m) ]
    --[ RequestNs($S, $C, ns) ]->
    [ ]


axiom Equality:
    "All x y #i. Eq(x, y) @ #i ==> x = y"


// The last rule of the protocol can be executed.
lemma Executable:
    exists-trace
    "Ex C S ns keyS keyC #i. Resp_Server(C, S, ns, keyC, keyS) @ #i"


// If a server and a client think they executed a session together, the adversary does not know the derived key.
lemma Key_secrecy_1:
    all-traces
    "All C S nc ns keyS keyC #i #j. (Resp_Server(C, S, ns, keyC, keyS) @ #i & Resp_Client(C, S, nc, keyS, keyC) @ #j) ==> (All #k. K(h(<nc, ns>)) @ #k ==> F) "


//// If a server and a client think they executed a session (but not necessarily with each other), the adversary does not know the derived key.
//// This is false, as the adversary can execute a man-in-the-middle attack.
//lemma Key_secrecy_2:
//    all-traces
//    "All nc ns keyS keyC keyS1 keyC1 #i #j. (Resp_Server(ns, keyC, keyS) @ #i & Resp_Client(nc, keyS1, keyC1) @ #j) ==> (All #k. K(h(<nc, ns>)) @ #k ==> F) "
//
//
//// If a server and a client think they executed a session together and used valid keys, the adversary does not know the derived key.
//lemma Key_secrecy_3:
//    all-traces
//    "All nc ns keyS keyC S C #i #j #m #n. (
//        Resp_Server(ns, keyC, keyS) @ #i & 
//        Resp_Client(nc, keyS, keyC) @ #j & 
//        ServerKey(S, keyS) @ #m & 
//        ClientKey(C, keyC) @ #n
//    ) ==> (All #k. K(h(<nc, ns>)) @ #k ==> F) "
//
//
//// If a server and a client think they executed a session (but not necessarily with each other) and used valid keys, the adversary does not know the derived key.
//lemma Key_secrecy_4:
//    all-traces
//    "All nc ns keyS keyC keyS1 keyC1 S C S1 C1 #i #j #m #n. (
//        Resp_Server(C, S, ns, keyC, keyS) @ #i & 
//        Resp_Client(C, S, nc, keyS1, keyC1) @ #j & 
//        ServerKey(S, keyS) @ #m & 
//        ClientKey(C, keyC) @ #n &
//        ServerKey(S1, keyS1) @ #m & 
//        ClientKey(C1, keyC1) @ #n
//    ) ==> (All #k. K(h(<nc, ns>)) @ #k ==> F) "


// The four rules are always executed in correct order within one session.
lemma Order:
    all-traces
    "All C S nc ns pkc pks #i #j #k #l. ((Init(C,S) @ #i & Resp(C,S) @ #j & Resp_Client(C,S,nc,pkc,pks) @ k & Resp_Server(C,S,ns,pkc,pks) @ #l) ==> (#i < #j & #j < #k & #k < #l) )"


// Client authenticates server on nc.
lemma Nc_auth:
    all-traces
    "All C S m #i . RequestNc(C, S, m) @ #i ==> (Ex #j . WitnessNc(C, S, m) @ #j & j<i)"


// Server authenticates client on ns.
lemma Ns_auth:
    all-traces
    "All C S m #i . RequestNs(C, S, m) @ #i ==> (Ex #j . WitnessNs(C, S, m) @ #j & j<i)"

end
