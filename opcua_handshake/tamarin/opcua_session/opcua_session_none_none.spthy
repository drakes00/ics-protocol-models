theory OPCUA_Session
begin

section{* OPCUA_Sessoion *}

/*
 * Protocol:    OPCUA_Session
 * Modeler:     Dreier Jannik, Maxime Puys and Pascal Lafourcade      
 * Date:        27 june 2016
 * Status:      OPCUA Create Session
 */

builtins: signing, symmetric-encryption, hashing

/* Equations for MAC, similar as signature but with symmetric keys */
functions : mac/2, verifyMac/3, login/1, passwd/2, verifyCreds/3
equations: verifyMac(mac(m, sk), m, sk)=true, verifyCreds(pkS, login(pk(skC)), passwd(skC, pkS)) = true


/* Public keys generation */
rule genServerKey:
    [ Fr(~x) ]
    --[ ServerKey($S, pk(~x)) ]->
    [ !Ltk($S, ~x), Out(<$S, pk(~x)>)]


rule genClientKey:
    [ Fr(~x) ]
    --[ ClientKey($C, pk(~x)) ]->
    [ !Ltk($C, ~x), Out(<$C, pk(~x)>)]


rule corrupt:
    [ !Ltk($C, ~x) ]
    --[ Corrupt($C, pk(~x)) ]->
    [ Out(<$C, ~x>) ]


/* Shared keys session generation */
rule genSharedKeySign:
    [ Fr(~x) ]
    --[ SharedKey('sign', $C, $S, ~x), Neq($C, $S) ]->
    [ !LtkSym('sign', $C, $S, ~x) ]


rule genSharedKeyEnc:
    [ Fr(~x) ]
    --[ SharedKey('enc', $C, $S, ~x), Neq($C, $S) ]->
    [ !LtkSym('enc', $C, $S, ~x) ]


/* C -> S : {CSReq, pk(C), NC}_KCS, MAC(KSigCS, (CSReq, pk(C), NC)) */
/* Where NC is a fresh nonce generated by C */
rule Client_Init:
let 
    m = <'CSReq', pk(~skc), ~nc>
in     
    [Fr(~nc), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !Ltk($C, ~skc), !LtkSym('enc', $S, $C, keySC), !LtkSym('sign', $S, $C, keySigSC)]
    --[ Init_Client($C,$S,~nc), KeyClient($C, $S, keyCS, keySC, keySigCS, keySigSC) ]->
    [ Out(m), Session_Client($C, $S, ~nc) ]


/* S  -> C : {CSRes, pk(S), SigNC, NS}_KSC, MAC(KSigSC, (CSRes, pk(S), SigNC, NS)) */
/* Where NS is a fresh nonce generated by S */
rule Server_Init:
let
    m = <'CSReq', pk(~skc), nc>
    mac1 = mac(m, keySigCS)
    sigNc = sign(h(nc), ~sks)
    m2 = <'CSRes', pk(~sks), nc, ~ns>
in
    [ In(m), Fr(~ns), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !LtkSym('enc', $S, $C, keySC), !LtkSym('sign', $S, $C, keySigSC), !Ltk($S, ~sks), !Ltk($C, ~skc) ]
    --[ Init_Server($C,$S,~ns), WitnessSigNc($S, $C, nc), KeyServer($C, $S, keyCS, keySC, keySigCS, keySigSC) ]->
    [ Out(m2), Session_Server($C, $S, ~ns) ]


/* C -> S : {ASReq, SigNS, pk(C), Login, Passwd}_KCS, MAC(KSigCS, (ASReq, SigNS, pk(C), Login, Passwd)) */
rule Resp_Client:
let
    m = <'CSRes', pk(~sks), ~nc, ns>
    mac1 = mac(m, keySigSC)
    log = login(pk(~skc))
    pass = passwd(~skc, pk(~sks))
    sigNs = sign(h(ns), ~skc)
    m2 = <'ASReq', pk(~skc), ns, log, pass>
in
    [ In(m), !LtkSym('enc', $S, $C, keySC), !LtkSym('sign', $S, $C, keySigSC), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !Ltk($C, ~skc), !Ltk($S, ~sks), Session_Client($C, $S, ~nc) ]
    --[ Resp_Client($C,$S,~nc,ns), WitnessPasswd($C, $S, pass), RequestSigNc($S, $C, ~nc), WitnessSigNs($C, $S, ns) ]->
    [ Out(m2) ]


/* S -> C : {ASRes, NS2}_KSC, MAC(KSigSC, (ASRes, NS2)) */
/* Where NS2 is a fresh nonce generated by S */
rule Resp_Server:
let
    m = <'ASReq', pk(~skc), ~ns, login, passwd>
    mac1 = mac(m, keySigCS)
    m2 = <'ASRes', ~ns2>
in
    [ In(m), Fr(~ns2), !LtkSym('enc', $S, $C, keySC), !LtkSym('sign', $S, $C, keySigSC), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !Ltk($C, ~skc), !Ltk($S, ~sks), Session_Server($C, $S, ~ns)]
    --[ Eq(verifyCreds(pk(~sks), login, passwd), true), Resp_Server($C,$S,~ns,~ns2), RequestPasswd($C, $S, passwd), RequestSigNs($C, $S, ~ns) ]->
    [ Out(m2) ]


axiom Equality:
    "All x y #i. Eq(x, y) @ #i ==> x = y"


axiom Inequality:
    "All x #i. Neq(x, x) @ #i ==> F"


// The protocol is executable.
lemma Executable:
    exists-trace
    "Ex C S ns ns2 #i. Resp_Client(C,S,ns,ns2) @ #i"


// The adversary can only know the passwords of corrupted clients.
lemma Password_secrecy_client:
    all-traces
    "All pkS skC C #i #j.((K(passwd(skC, pkS)) @ #i & ClientKey(C, pk(skC)) @ #j) ==> (Ex #k. Corrupt(C, pk(skC)) @ #k))"


// The adversary can only know the passwords of currpted servers.
lemma Password_secrecy_server:
    all-traces
    "All pkS skC C #i #j.((K(passwd(skC, pkS)) @ #i & ServerKey(C, pk(skC)) @ #j) ==> (Ex #k. Corrupt(C, pk(skC)) @ #k))"


// The four rules are always executed in correct order within one session.
// FIXME: ram exhausted /!\
lemma Order:
    all-traces
    "All C S nc ns ns2 #i #j #k #l. ((Init_Client(C,S,nc) @ #i & Init_Server(C,S,ns) @ #j & Resp_Client(C,S,nc,ns) @ k & Resp_Server(C,S,ns,ns2) @ #l) ==> (#i < #j & #j < #k & #k < #l) )"


// Server authenticates client on password.
lemma Password_auth:
    all-traces
    "All C S m #i . RequestPasswd(C, S, m) @ #i ==> (Ex #j . WitnessPasswd(C, S, m) @ #j & j<i)"


// Client authenticates server on nc signature.
lemma SigNc_auth:
    all-traces
    "All C S m #i . RequestSigNc(C, S, m) @ #i ==> (Ex #j . WitnessSigNc(C, S, m) @ #j & j<i)"


// Server authenticates client on ns signature.
lemma SigNs_auth:
    all-traces
    "All C S m #i . RequestSigNs(C, S, m) @ #i ==> (Ex #j . WitnessSigNs(C, S, m) @ #j & j<i)"


// If a server and a client think they executed a session together, the adversary does not know the shared key used.
lemma KeyCS_secrecy:
    all-traces
    "All C S keyCS keySC keySigCS keySigSC #i #j . (KeyClient(C, S, keyCS, keySC, keySigCS, keySigSC) @ #i & KeyServer(C, S, keyCS, keySC, keySigCS, keySigSC) @ #j) ==> (All #k . K(keyCS) @ #k ==> F)"


// If a server and a client think they executed a session together, the adversary does not know the shared key used.
lemma KeySC_secrecy:
    all-traces
    "All C S keyCS keySC keySigCS keySigSC #i #j . (KeyClient(C, S, keyCS, keySC, keySigCS, keySigSC) @ #i & KeyServer(C, S, keyCS, keySC, keySigCS, keySigSC) @ #j) ==> (All #k . K(keySC) @ #k ==> F)"


// If a server and a client think they executed a session together, the adversary does not know the shared key used.
lemma KeySigCS_secrecy:
    all-traces
    "All C S keyCS keySC keySigCS keySigSC #i #j . (KeyClient(C, S, keyCS, keySC, keySigCS, keySigSC) @ #i & KeyServer(C, S, keyCS, keySC, keySigCS, keySigSC) @ #j) ==> (All #k . K(keySigCS) @ #k ==> F)"


// If a server and a client think they executed a session together, the adversary does not know the shared key used.
lemma KeySigSC_secrecy:
    all-traces
    "All C S keyCS keySC keySigCS keySigSC #i #j . (KeyClient(C, S, keyCS, keySC, keySigCS, keySigSC) @ #i & KeyServer(C, S, keyCS, keySC, keySigCS, keySigSC) @ #j) ==> (All #k . K(keySigSC) @ #k ==> F)"

end
