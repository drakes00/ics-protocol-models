theory OPCUA
begin

section{* OPCUA *}

/*
 * Protocol:        OPCUA
 * Modeler:   Dreier Jannik, Maxime Puys and Pascal Lafourcade      
 * Date:         17 june 2016
 * Status:      OPCUA Open secure channel
 */

builtins: signing, asymmetric-encryption, hashing

rule genServerKey:
  [ Fr(~x) ]
  --[ ServerKey($S,pk(~x)) ]->
  [ !Ltk($S,~x), Out(<$S,pk(~x)>)]

rule genClientKey:
  [ Fr(~x) ]
  --[ ClientKey($C,pk(~x)) ]->
  [ !Ltk($C,~x), Out(<$C,pk(~x)>)]

/*
rule corrupt:
  [ !Ltk($C,~x) ]
  --[ Corrupt($C,pk(~x)) ]->
  [ Out(<$C,~x>) ]
*/

/* C -> DE : GEReq */
rule Init:
 [ ]
 --[ Init() ]->
 [ Out('GEReq') ]


/* DE  -> C : GERes, pk(S), SignEnc, SP, UP */
rule Resp_Init:
 [ In('GEReq'), !Ltk($S,~x) ]
 --[ Resp() ]->
 [ Out(<'GERes',pk(~x),'SignEnc',$SP, $UP>) ]


/* C -> S : pk(C), aenc(<OSCReq, pk(C),Nc>,pk(S) , sign(h(OSCReq,pk(C), Nc ), sk(C) ) */
/* Where Nc is a fresh nonce generated by C */

rule Resp_Client:
 [ In(<'GERes',keyS,'SignEnc',sp,up>), !Ltk($C,~x), Fr(~nc) ]
 --[ Resp_Client(~nc,keyS,pk(~x)) ]->
 [ Out(<pk(~x), aenc(<'OSCReq', pk(~x),~nc>,keyS), sign{h(<'OSCReq',pk(~x),~nc>)}~x, h(<'OSCReq',pk(~x),~nc>)>) ]

/* SE -> C : aenc(<OSCRes, NS , ST, TTL>, pk(C)), sign(h(OSCRes, NS , ST, TTL), sk(S)) */
rule Resp_Server:
 [ !Ltk($S,~x), In(<keyC, aenc(<'OSCReq', keyC, nc>,pk(~x)), signature, h(<'OSCReq',keyC,nc>)>), Fr(~ns)]
 --[ Eq(verify(signature, h(<'OSCReq',keyC, nc>), keyC), true), Resp_Server(~ns,keyC,pk(~x)) ]->
 [ Out(<pk(~x), aenc(<'OSCRes', ~ns, $ST, $TTL>,keyC), sign{h(<'OSCRes', ~ns, $ST, $TTL>)}~x, h(<'OSCRes', ~ns, $ST, $TTL>)>) ]

axiom Equality:
    "All x y #i. Eq(x, y) @ #i ==> x = y"

lemma Executable:
  exists-trace
  "Ex ns keyS keyC #i. Resp_Server(ns,keyC,keyS) @ #i"

lemma Key_secrecy_1:
  all-traces
  "All nc ns keyS keyC #i #j. (Resp_Server(ns,keyC,keyS) @ #i & Resp_Client(nc,keyS,keyC) @ #j) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

lemma Key_secrecy_2:
  all-traces
  "All nc ns keyS keyC keyS1 keyC1 #i #j. (Resp_Server(ns,keyC,keyS) @ #i & Resp_Client(nc,keyS1,keyC1) @ #j) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

lemma Key_secrecy_3:
  all-traces
  "All nc ns keyS keyC S C #i #j #m #n. (
    Resp_Server(ns,keyC,keyS) @ #i & 
    Resp_Client(nc,keyS,keyC) @ #j & 
    ServerKey(S,keyS) @ #m & 
    ClientKey(C,keyC) @ #n
   ) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

lemma Key_secrecy_4:
  all-traces
  "All nc ns keyS keyC keyS1 keyC1 S C S1 C1 #i #j #m #n. (
    Resp_Server(ns,keyC,keyS) @ #i & 
    Resp_Client(nc,keyS1,keyC1) @ #j & 
    ServerKey(S,keyS) @ #m & 
    ClientKey(C,keyC) @ #n &
    ServerKey(S1,keyS1) @ #m & 
    ClientKey(C1,keyC1) @ #n
   ) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

end


