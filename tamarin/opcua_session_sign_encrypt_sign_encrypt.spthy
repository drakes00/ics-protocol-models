theory OPCUA
begin

section{* OPCUA *}

/*
 * Protocol:        OPCUA
 * Modeler:   Dreier Jannik, Maxime Puys and Pascal Lafourcade      
 * Date:         27 june 2016
 * Status:      OPCUA Create Session
 */

builtins: signing, symmetric-encryption, hashing

/* TODO, generate four shared symmetric keys */
/* TODO, generate login/password for client */

/* Equations for MAC, similar as signature but with symmetric keys */
functions : mac/2, verify/3
equations: verify(mac(m,sk),m,sk)=true


rule genServerKey:
  [ Fr(~x) ]
  --[ ServerKey($S,pk(~x)) ]->
  [ !Ltk($S,~x), Out(<$S,pk(~x)>)]

rule genClientKey:
  [ Fr(~x) ]
  --[ ClientKey($C,pk(~x)) ]->
  [ !Ltk($C,~x), Out(<$C,pk(~x)>)]

/*
rule corrupt:
  [ !Ltk($C,~x) ]
  --[ Corrupt($C,pk(~x)) ]->
  [ Out(<$C,~x>) ]
*/


/* Shared keys session generation */
rule genSharedKey:
  [ Fr(~x) ]
  --[ SharedKey($C,$S,keyCS(~x)) ]->
  [ !Ltk($C,$S,keyCS(~x)]



/* C -> S : {CSReq, pk(C), NC}_KCS, MAC(KSigCS, (CSReq, pk(C), NC)) */
/* Where NC is a fresh nonce generated by C */


rule Init:
let 
     m= <'CSReq',pk(C),~nc>
in     
 [Fr(~nc)]
 --[ Init() ]->
 [ Out(<senc(m,keyCS),mac(m, keySigCS)> ]


/* S  -> C : {CSRes, pk(S), SigNC, NS}_KSC , MAC(KSigSC, (CSRes, pk(S), SigNC, NS)) */
/* Where NS is a fresh nonce generated by S */


rule Resp_Init:
let
m = <'CSReq',pk(C),nc>
m2 = <'CSRes',pk(S),sign(h(nc),sk(C)),~ns>
mac1 = mac(m, keySigCS)
in
 [ In(<senc(m,keyCS),mac1>), Fr(~ns) ]
 --[ Eq(verify(mac1,m,keySigCS)=true), Resp() ]->
 [ Out(<senc(m2, keySC), mac(m2, keySigSC)>) ]


/* C -> S : {ASReq, SigNS , pk(C), Login, Passwd}_KCS , MAC(KSigCS, (ASReq, SigNS , pk(C), Login, Passwd)) */
rule Resp_Client:
let
m = <'CSRes',pk(S),sign(h(nc),sk(C)),ns>
m2 = <'ASReq',sign(h(ns), sk(C)), pk(C), 'Login','Passwd'>
mac1 = mac(m, keySigSC)
in
 [ In(<senc(m, keySC), mac1>) ]
 --[ Eq(verify(mac1, m, keySigSC), true), Resp_Client(~nc,keyS,pk(~x)) ]->
 [ Out(<senc(m2, keyCS), mac(m2, keySigCS)>) ]

/* S -> C : {ASRes, NS2}_KSC, MAC(KSigSC, (ASRes, NS2)) */
/* Where NS2 is a fresh nonce generated by S */

rule Resp_Server:
let
m = <'ASReq',sign(h(ns), sk(C)), pk(C), 'Login','Passwd'>
m2 = <'ASRes',~ns2>
mac1 = mac(m, keySigCS)
in
 [ In(<senc(m,keyCS),mac1>), Fr(~ns2)]
 --[ Eq(verify(mac1, m, keySigCS), true), Resp_Server(~ns,keyC,pk(~x)) ]->
 [ Out(<senc(m2, keySC), mac(m2, keySigSC)>) ]

axiom Equality:
    "All x y #i. Eq(x, y) @ #i ==> x = y"


/* TODO secrecy of Keys, secrecy of Passwd, auth on Passwd, auth on sigNC, auth on sigNS*/

lemma Executable:
  exists-trace
  "Ex ns keyS keyC #i. Resp_Server(ns,keyC,keyS) @ #i"

lemma Key_secrecy_1:
  all-traces
  "All nc ns keyS keyC #i #j. (Resp_Server(ns,keyC,keyS) @ #i & Resp_Client(nc,keyS,keyC) @ #j) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

lemma Key_secrecy_2:
  all-traces
  "All nc ns keyS keyC keyS1 keyC1 #i #j. (Resp_Server(ns,keyC,keyS) @ #i & Resp_Client(nc,keyS1,keyC1) @ #j) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

lemma Key_secrecy_3:
  all-traces
  "All nc ns keyS keyC S C #i #j #m #n. (
    Resp_Server(ns,keyC,keyS) @ #i & 
    Resp_Client(nc,keyS,keyC) @ #j & 
    ServerKey(S,keyS) @ #m & 
    ClientKey(C,keyC) @ #n
   ) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

lemma Key_secrecy_4:
  all-traces
  "All nc ns keyS keyC keyS1 keyC1 S C S1 C1 #i #j #m #n. (
    Resp_Server(ns,keyC,keyS) @ #i & 
    Resp_Client(nc,keyS1,keyC1) @ #j & 
    ServerKey(S,keyS) @ #m & 
    ClientKey(C,keyC) @ #n &
    ServerKey(S1,keyS1) @ #m & 
    ClientKey(C1,keyC1) @ #n
   ) ==> (All #k. K(h(<nc,ns>)) @ #k ==> F) "

end

