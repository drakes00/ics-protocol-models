theory OPCUA_Session
begin

section{* OPCUA_Sessoion *}

/*
 * Protocol:    OPCUA_Session
 * Modeler:     Dreier Jannik, Maxime Puys and Pascal Lafourcade      
 * Date:        27 june 2016
 * Status:      OPCUA Create Session
 */

builtins: signing, symmetric-encryption, hashing

/* Equations for MAC, similar as signature but with symmetric keys */
functions : mac/2, verifyMac/3, login/1, passwd/2, verifyCreds/3
equations: verifyMac(mac(m, sk), m, sk)=true, verifyCreds(pkS, login(pk(skC)), passwd(skC, pkS)) = true


rule genServerKey:
    [ Fr(~x) ]
    --[ ServerKey($S, pk(~x)) ]->
    [ !Ltk($S, ~x), Out(<$S, pk(~x)>)]

rule genClientKey:
    [ Fr(~x) ]
    --[ ClientKey($C, pk(~x)) ]->
    [ !Ltk($C, ~x), Out(<$C, pk(~x)>)]

rule corrupt:
    [ !Ltk($C, ~x) ]
    --[ Corrupt($C, pk(~x)) ]->
    [ Out(<$C, ~x>) ]


/* Shared keys session generation */
rule genSharedKeySign:
    [ Fr(~x) ]
    --[ SharedKey('sign', $C, $S, ~x), Neq($C, $S) ]->
    [ !LtkSym('sign', $C, $S, ~x) ]

rule genSharedKeyEnc:
    [ Fr(~x) ]
    --[ SharedKey('enc', $C, $S, ~x), Neq($C, $S) ]->
    [ !LtkSym('enc', $C, $S, ~x) ]


/* C -> S : {CSReq, pk(C), NC}_KCS, MAC(KSigCS, (CSReq, pk(C), NC)) */
/* Where NC is a fresh nonce generated by C */
rule Client_Init:
let 
    m= <'CSReq', pk(~skc), ~nc>
in     
    [Fr(~nc), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !Ltk($C, ~skc)]
    --[ Init_Client($C,$S,~nc) ]->
    [ Out(<senc(m, keyCS), mac(m, keySigCS)>), Session_Client($C, $S, ~nc) ]


/* S  -> C : {CSRes, pk(S), SigNC, NS}_KSC, MAC(KSigSC, (CSRes, pk(S), SigNC, NS)) */
/* Where NS is a fresh nonce generated by S */
rule Server_Init:
let
    m = <'CSReq', pk(~skc), nc>
    mac1 = mac(m, keySigCS)
    m2 = <'CSRes', pk(~sks), sign(h(nc), ~sks), ~ns>
in
    [ In(<senc(m, keyCS), mac1>), Fr(~ns), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !LtkSym('enc', $S, $C, keySC), !LtkSym('sign', $S, $C, keySigSC), !Ltk($S, ~sks), !Ltk($C, ~skc) ]
    --[ Eq(verifyMac(mac1, m, keySigCS), true), Init_Server($C,$S,~ns) ]->
    [ Out(<senc(m2, keySC), mac(m2, keySigSC)>), Session_Server($C, $S, ~ns) ]


/* C -> S : {ASReq, SigNS, pk(C), Login, Passwd}_KCS, MAC(KSigCS, (ASReq, SigNS, pk(C), Login, Passwd)) */
rule Resp_Client:
let
    m = <'CSRes', pk(~sks), signature, ns>
    mac1 = mac(m, keySigSC)
    log = login(pk(~skc))
    pass = passwd(~skc, pk(~sks))
    m2 = <'ASReq', sign(h(ns), ~skc), pk(~skc), log, pass>
in
    [ In(<senc(m, keySC), mac1>), !LtkSym('enc', $S, $C, keySC), !LtkSym('sign', $S, $C, keySigSC), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !Ltk($C, ~skc), !Ltk($S, ~sks), Session_Client($C, $S, ~nc) ]
    --[ Eq(verify(signature, h(~nc), pk(~sks)), true), Eq(verifyMac(mac1, m, keySigSC), true), Resp_Client($C,$S,~nc,ns), WitnessPasswd($C, $S, pass) ]->
    [ Out(<senc(m2, keyCS), mac(m2, keySigCS)>) ]


/* S -> C : {ASRes, NS2}_KSC, MAC(KSigSC, (ASRes, NS2)) */
/* Where NS2 is a fresh nonce generated by S */
rule Resp_Server:
let
    m = <'ASReq', signature, pk(~skc), login, passwd>
    mac1 = mac(m, keySigCS)
    m2 = <'ASRes', ~ns2>
in
    [ In(<senc(m, keyCS), mac1>), Fr(~ns2), !LtkSym('enc', $S, $C, keySC), !LtkSym('sign', $S, $C, keySigSC), !LtkSym('enc', $C, $S, keyCS), !LtkSym('sign', $C, $S, keySigCS), !Ltk($C, ~skc), !Ltk($S, ~sks), Session_Server($C, $S, ~ns)]
    --[ Eq(verifyCreds(pk(~sks), login, passwd), true), Eq(verify(signature, h(~ns), pk(~skc)), true), Eq(verifyMac(mac1, m, keySigCS), true), Resp_Server($C,$S,~ns,~ns2), RequestPasswd($C, $S, passwd) ]->
    [ Out(<senc(m2, keySC), mac(m2, keySigSC)>) ]


axiom Equality:
    "All x y #i. Eq(x, y) @ #i ==> x = y"


axiom Inequality:
    "All x #i. Neq(x, x) @ #i ==> F"


/* TODO secrecy of Keys, auth on Passwd, auth on sigNC, auth on sigNS */

// The protocol is executable
lemma Executable:
  exists-trace
  "Ex C S ns ns2 #i. Resp_Server(C,S,ns,ns2) @ #i"

// The adversary can only know the passwords of corrupted clients
lemma Password_secrecy_client:
  all-traces
  "All pkS skC C #i #j.((K(passwd(skC, pkS)) @ #i & ClientKey(C, pk(skC)) @ #j) ==> (Ex #k. Corrupt(C, pk(skC)) @ #k))"

// The adversary can only know the passwords of currpted servers
lemma Password_secrecy_server:
  all-traces
  "All pkS skC C #i #j.((K(passwd(skC, pkS)) @ #i & ServerKey(C, pk(skC)) @ #j) ==> (Ex #k. Corrupt(C, pk(skC)) @ #k))"

// The four rules are always executed in correct order within one session
lemma Order:
  all-traces
  "All C S nc ns ns2 #i #j #k #l. ((Init_Client(C,S,nc) @ #i & Init_Server(C,S,ns) @ #j & Resp_Client(C,S,nc,ns) @ k & Resp_Server(C,S,ns,ns2) @ #l) ==> (#i < #j & #j < #k & #k < #l) )"


lemma Password_auth:
  all-traces
  "All C S m #i . RequestPasswd(C, S, m) @ #i ==> (Ex #j . WitnessPasswd(C, S, m) @ #j & j<i)"


lemma SignNc_auth:
  all-traces
  "All C S m #i . RequestSignNc(C, S, m) @ #i ==> (Ex #j . WitnessSignNc(C, S, m) @ #j & j<i)"

/*
lemma Key_secrecy_2:
  all-traces
  "All nc ns keyS keyC keyS1 keyC1 #i #j. (Resp_Server(ns, keyC, keyS) @ #i & Resp_Client(nc, keyS1, keyC1) @ #j) ==> (All #k. K(h(<nc, ns>)) @ #k ==> F) "

lemma Key_secrecy_3:
  all-traces
  "All nc ns keyS keyC S C #i #j #m #n. (
    Resp_Server(ns, keyC, keyS) @ #i & 
    Resp_Client(nc, keyS, keyC) @ #j & 
    ServerKey(S, keyS) @ #m & 
    ClientKey(C, keyC) @ #n
   ) ==> (All #k. K(h(<nc, ns>)) @ #k ==> F) "

lemma Key_secrecy_4:
  all-traces
  "All nc ns keyS keyC keyS1 keyC1 S C S1 C1 #i #j #m #n. (
    Resp_Server(ns, keyC, keyS) @ #i & 
    Resp_Client(nc, keyS1, keyC1) @ #j & 
    ServerKey(S, keyS) @ #m & 
    ClientKey(C, keyC) @ #n &
    ServerKey(S1, keyS1) @ #m & 
    ClientKey(C1, keyC1) @ #n
   ) ==> (All #k. K(h(<nc, ns>)) @ #k ==> F) "
*/

end

