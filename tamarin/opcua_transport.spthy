theory OPCUA_Transport
begin

section{* OPCUA_Transport *}

/*
 * Protocol:    OPCUA_Transport
 * Modeler:     Dreier Jannik, Maxime Puys and Pascal Lafourcade      
 * Date:        27 june 2016
 * Status:      OPCUA Transport
 */

builtins: signing, symmetric-encryption, hashing, multiset

/* Equations for MAC, similar as signature but with symmetric keys */
functions : mac/2, verifyMac/3, login/1, passwd/2, verifyCreds/3, suc/1, zero/0
equations: verifyMac(mac(m, sk), m, sk)=true //, suc(suc(suc(suc(x))))=x


/* Shared keys session generation */
rule genSharedKeySign:
    [ Fr(~x) ]
    --[ SharedKey('sign', $C, $S, ~x), Neq($C, $S) ]->
    [ !LtkSym('sign', $C, $S, ~x) /*, !LtkSym('sign', $S, $C, ~x) */ ]

rule genSharedKeyEnc:
    [ Fr(~x) ]
    --[ SharedKey('enc', $C, $S, ~x), Neq($C, $S) ]->
    [ !LtkSym('enc', $C, $S, ~x) /*, !LtkSym('enc', $S, $C, ~x) */ ]

/*
rule corrupt:
    [ !LtkSym(type, $C, $S, ~x) ]
    --[ Corrupt(type, $C, $S, ~x) ]->
    [ Out(<type, $C, $S, ~x>) ]
*/

rule initA:
    [ ]
    --[ InitA($A, $B) ]->
    [ State_A($A, $B, zero) ]

rule Send_A:
    let m = ~m
    in
    [ Fr(~m), !LtkSym('enc', $A, $B, keyEncAB), !LtkSym('sign', $A, $B, keySigAB), State_A($A, $B, seq) ]
    --[ Send($A, $B, m), Seq_Send($A, $B, seq) ]->
    [ Out(<$MH, $SH, senc(<seq, m, $pad, mac(<$MH, $SH, seq, m, $pad>, keySigAB)>, keyEncAB)>), State_A($A, $B, suc(seq)) ]

rule Recv_B:
    [!LtkSym('enc', $A, $B, keyEncAB), !LtkSym('sign', $A, $B, keySigAB), In(<MH, SH, senc(<seq, m, pad, mac(<MH, SH, seq, m, pad>, keySigAB)>, keyEncAB)>) ]
    --[ Recv($A, $B, m), Seq_Recv($A, $B, seq) ]->
    [  ]


axiom Equality:
    "All x y #i. Eq(x, y) @ #i ==> x = y"


axiom Inequality:
    "All x #i. Neq(x, x) @ #i ==> F"

axiom Unique_Sequence_Number_A:
    "All A B #i #j. ((InitA(A, B) @ #i & InitA(A, B) @ #j) ==> #i = #j)"

axiom Unique_Sequence_Number_B:
    "All A B seq #i #j. ((Seq_Recv(A, B, seq) @ #i & Seq_Recv(A, B, seq) @ #j) ==> #i = #j)"

axiom Increment_Sequence_Number_B:
    "All A B seq #i. ((Seq_Recv(A, B, seq) @ #i) ==> (
    ((seq = zero) & (not(Ex seq3 #k. (Seq_Recv(A, B, seq3) @ #k & #k < #i)) ))
    | (Ex seq2. (seq = suc(seq2) & ( 
    (Ex #j. Seq_Recv(A, B, seq2) @ #j & #j < #i) |
    (not(Ex seq3 #k. (Seq_Recv(A, B, seq3) @ #k & #k < #i)) )
    )))))"

// Typing Lemma ?
//lemma open_chains [typing]:
//    "All A B seq #i.(Seq_Send(A, B, seq) @ #i ==> (seq = '1' | Ex x. seq = '1' + x))"

/*
axiom Test:
    "All A B seq #i.(Seq_Send(A, B, seq) @ #i ==> (seq = '1' | seq = '1' + '1' | seq = '1' + '1' + '1' | seq = '1' + '1' + '1' + '1'))"
*/
axiom Test:
    "All A B seq #i.(Seq_Send(A, B, seq) @ #i ==> (seq = zero | seq = suc(zero) | seq = suc(suc(zero)) | seq = suc(suc(suc(zero)))))"

axiom Test2:
    "All A B seq #i.(Seq_Recv(A, B, seq) @ #i ==> (seq = zero | seq = suc(zero) | seq = suc(suc(zero)) | seq = suc(suc(suc(zero)))))"

// The protocol is executable.
lemma Executable:
    exists-trace
    "Ex A B m #i. Recv(A, B, m) @ #i"


// Non-Injective Message Integrity
lemma NIMI:
    all-traces
    "All A B m #i.(Recv(A,B,m) @ #i ==> (Ex #k. Send(A,B,m) @ #k))"


// Injective Message Integrity
lemma IMI:
    "All A B t #i. 
    Recv(A,B,t) @i
    ==> (Ex #j. Send(A,B,t) @j 
        & j < i
        & not (Ex A2 B2 #i2. Recv(A2,B2,t) @i2
                           & not (#i2 = #i)))"

// Flow Integrity
lemma FI:
    all-traces
    "All A B m m2 #i #j.(Recv(A,B,m) @ #i & Recv(A,B,m2) @ #j & #i < #j ==> (Ex #k #l. (Send(A,B,m) @ #k & Send(A,B,m2) @ #l & #k < #l) ))"


end
