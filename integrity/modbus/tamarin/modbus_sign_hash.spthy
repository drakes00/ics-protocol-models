theory Modbus_Sign_Hash
begin

section{* Modbus_Sign_Hash *}

/*
 * Protocol:    Modbus with hash and signatures
 * Modeler:     Jannik Dreier, Maxime Puys and Pascal Lafourcade      
 * Date:        5 September 2016
 * Status:      Done (broken)
 */

// [TS|n|Modbus]{SHA2(TS|n|Modbus)}pKm

builtins: signing, hashing, multiset

/* Key generation */
rule genKeySign:
    [ Fr(~x) ]
    --[ Key($P, ~x) ]->
    [ !Ltk($P, ~x), Out(pk(~x)) ]

    
rule Send_A:
    let message = <ts, n, $M, sign(h(<ts, n, $M>), ~key)>
    in
    [ In(ts), In(n), !Ltk($A, ~key) ]
    --[ Send($A, $B, <$M, ts>), Timestamp($A,ts), Seq_Sent($A, $B, n), Sent(message) ]->
    [ Out(message) ]

rule Recv_B:
    let message = <ts, n, m, sign(h(<ts, n, m>), ~key)>
    in
    [ !Ltk($A, ~key), In(message) ]
    --[ Recv($A, $B, <m, ts>), Timestamp($B,ts), Seq_Recv($A, $B, n), Received(message) ]->
    [  ]

// AXIOMS

// A's counter increases
axiom A_Counter_Increases:
    "All A B seq1 seq2 #i #j.(Seq_Sent(A, B, seq1) @ #i & Seq_Sent(A, B, seq2) @ #j & #i < #j ==> Ex dif. seq2 = seq1 + dif )"

// B's counter counter increases
axiom B_Counter_Counter_Increases:
    "All A B seq1 seq2 #i #j.(Seq_Recv(A, B, seq1) @ #i & Seq_Recv(A, B, seq2) @ #j & #i < #j ==> Ex dif. seq2 = seq1 + dif )"

// Timestamps increase
axiom Timestamp_increase:
    "All P ts1 ts2 #i #j.(Timestamp(P,ts1) @ #i & Timestamp_A(P,ts2) @ #j & #i < #j ==> Ex dif. ts2 = ts1 + dif )"

// Delivery Axiom
axiom delivery:
    "All m #i. Sent(m) @ #i ==> Ex #j. Received(m) @ #j & #i < #j"

// LEMMAS

// The protocol is executable.
lemma Executable:
    exists-trace
    "Ex A B m #i. Recv(A, B, m) @ #i"


// Non-Injective Message Integrity
lemma NIMI:
    all-traces
    "All A B m #i.(Recv(A,B,m) @ #i ==> (Ex #k. Send(A,B,m) @ #k))"


// Injective Message Integrity
lemma IMI:
    "All A B t #i. 
    Recv(A,B,t) @i
    ==> (Ex #j. Send(A,B,t) @j 
        & j < i
        & not (Ex A2 B2 #i2. Recv(A2,B2,t) @i2
                           & not (#i2 = #i)))"

// Flow Integrity
lemma FI:
    all-traces
    "All A B m m2 #i #j.(Recv(A,B,m) @ #i & Recv(A,B,m2) @ #j & #i < #j ==> (Ex #k #l. (Send(A,B,m) @ #k & Send(A,B,m2) @ #l & #k < #l) ))"


// Non-Injective Message Delivery
lemma NIMD:
    all-traces
    "All A B m #i.(Send(A,B,m) @ #i ==> (Ex #k. Recv(A,B,m) @ #k))"

// Injective Message Delivery
lemma IMD:
    "All A B t #i. 
    Send(A,B,t) @i
    ==> (Ex #j. Recv(A,B,t) @j 
        & i < j
        & not (Ex A2 B2 #i2. Send(A2,B2,t) @i2
                           & not (#i2 = #i)))"

// Flow Delivery
lemma FD:
    all-traces
    "All A B m m2 #i #j.(Send(A,B,m) @ #i & Send(A,B,m2) @ #j & #i < #j ==> (Ex #k #l. (Recv(A,B,m) @ #k & Recv(A,B,m2) @ #l & #k < #l) ))"


end
