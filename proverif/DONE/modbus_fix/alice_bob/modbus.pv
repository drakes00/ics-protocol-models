(*  Modbus
    A -> B: mbap,fc,data
*)

free c: channel.

free cAO: channel [private].
free cBO: channel [private].

(* Signatures *)
type key.
fun pub(key): key.

fun h(bitstring): bitstring.
fun sign(bitstring, key): bitstring.
reduc forall x: bitstring, k: key ; verify(x, sign(x, k), pub(k)) = true.

(* Hosts *)
type host.
free Alice, Bob, Intruder: host.
free skA, skB: key [private].
free skI: key.

(* Integrity *)
event different(bitstring, bitstring).
query x: bitstring ; event(different((mbap, fc, data), x)).

(* Secrecy *)
free mbap,fc,data: bitstring [private].

query attacker(mbap).
query attacker(fc).
query attacker(data).

(* Authentication *)
event begin(host, host, bitstring).
event end(host, host, bitstring).
query a:host, b: host, x: bitstring ; event(end(Alice, Bob, x)) ==> event(begin(Alice, Bob, x)).

let oracle =
    in(cAO, m1: bitstring);
    in(cBO, m2: bitstring);
    if m1 = m2 then 0 else event different(m1, m2).

let alice(skA: key) =
    let m = (mbap, fc, data) in
    event begin(Alice, Bob, m);
    out(cAO, m);
    out(c, (m, sign(m, skA))).

let bob(pkA: key) =
    in(c, (x: bitstring, sigX: bitstring));
    if verify(x, sigX, pkA) <> true then 0 else
    out(cBO, x);
    event end(Alice, Bob, x).

process oracle | alice(skA) | bob(pub(skA))
