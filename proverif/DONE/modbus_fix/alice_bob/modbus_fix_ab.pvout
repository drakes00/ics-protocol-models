Process:
(
    {1}in(cAO, m1: bitstring);
    {2}in(cBO, m2: bitstring);
    {3}if (m1 = m2) then
        0
    else
        {4}event different(m1,m2)
) | (
    {5}let m: bitstring = (mbap,fc,data) in
    {6}event begin(Alice,Bob,m);
    {7}out(cAO, m);
    {8}out(c, (m,sign(m,skA)))
) | (
    {9}in(c, (x_42: bitstring,sigX: bitstring));
    {10}if (verify(x_42,sigX,pub(skA)) <> true) then
        0
    else
        {11}out(cBO, x_42);
        {12}event end(Alice,Bob,x_42)
)

-- Query event(end(Alice[],Bob[],x_43)) ==> event(begin(Alice[],Bob[],x_43))
Completing...
Starting query event(end(Alice[],Bob[],x_43)) ==> event(begin(Alice[],Bob[],x_43))
goal reachable: begin(begin(Alice[],Bob[],(mbap[],fc[],data[]))) -> end(end(Alice[],Bob[],(mbap[],fc[],data[])))
RESULT event(end(Alice[],Bob[],x_43)) ==> event(begin(Alice[],Bob[],x_43)) is true.
-- Query not attacker(data[])
Completing...
Starting query not attacker(data[])
goal reachable: attacker(data[])

1. The message ((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[])) may be sent to the attacker at output {8}.
attacker(((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[]))).

2. By 1, the attacker may know ((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[])).
Using the function 1-proj-2-tuple the attacker may obtain (mbap[],fc[],data[]).
attacker((mbap[],fc[],data[])).

3. By 2, the attacker may know (mbap[],fc[],data[]).
Using the function 3-proj-3-tuple the attacker may obtain data[].
attacker(data[]).


A more detailed output of the traces is available with
  set traceDisplay = long.

event(begin(Alice,Bob,(mbap,fc,data))) at {6}

out(cAO, (mbap,fc,data)) at {7} received at {1}

out(c, ((mbap,fc,data),sign((mbap,fc,data),skA))) at {8}

The attacker has the message data.
A trace has been found.
RESULT not attacker(data[]) is false.
-- Query not attacker(fc[])
Completing...
Starting query not attacker(fc[])
goal reachable: attacker(fc[])

1. The message ((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[])) may be sent to the attacker at output {8}.
attacker(((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[]))).

2. By 1, the attacker may know ((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[])).
Using the function 1-proj-2-tuple the attacker may obtain (mbap[],fc[],data[]).
attacker((mbap[],fc[],data[])).

3. By 2, the attacker may know (mbap[],fc[],data[]).
Using the function 2-proj-3-tuple the attacker may obtain fc[].
attacker(fc[]).


A more detailed output of the traces is available with
  set traceDisplay = long.

event(begin(Alice,Bob,(mbap,fc,data))) at {6}

out(cAO, (mbap,fc,data)) at {7} received at {1}

out(c, ((mbap,fc,data),sign((mbap,fc,data),skA))) at {8}

The attacker has the message fc.
A trace has been found.
RESULT not attacker(fc[]) is false.
-- Query not attacker(mbap[])
Completing...
Starting query not attacker(mbap[])
goal reachable: attacker(mbap[])

1. The message ((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[])) may be sent to the attacker at output {8}.
attacker(((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[]))).

2. By 1, the attacker may know ((mbap[],fc[],data[]),sign((mbap[],fc[],data[]),skA[])).
Using the function 1-proj-2-tuple the attacker may obtain (mbap[],fc[],data[]).
attacker((mbap[],fc[],data[])).

3. By 2, the attacker may know (mbap[],fc[],data[]).
Using the function 1-proj-3-tuple the attacker may obtain mbap[].
attacker(mbap[]).


A more detailed output of the traces is available with
  set traceDisplay = long.

event(begin(Alice,Bob,(mbap,fc,data))) at {6}

out(cAO, (mbap,fc,data)) at {7} received at {1}

out(c, ((mbap,fc,data),sign((mbap,fc,data),skA))) at {8}

The attacker has the message mbap.
A trace has been found.
RESULT not attacker(mbap[]) is false.
-- Query not event(different((mbap[],fc[],data[]),x_1068))
Completing...
Starting query not event(different((mbap[],fc[],data[]),x_1068))
RESULT not event(different((mbap[],fc[],data[]),x_1068)) is true.
