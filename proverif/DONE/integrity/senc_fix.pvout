Linear part:
Completing equations...
Completed equations:
Convergent part:
dec(y,enc(y,x)) = x
Completing equations...
Completed equations:
dec(y,enc(y,x)) = x
Process:
(
    {1}in(cAO, (X: host,Y: host,m1: bitstring));
    {2}in(cBO, (=X,=Y,m2: bitstring));
    {3}if (m1 = m2) then
        0
    else
        {4}event different(X,Y,m2)
) | (
    {5}in(c, (X_27: host,Y_28: host));
    {6}if ((X_27 <> A) && (X_27 <> B)) then
        0
    else
        {7}event sent(X_27,Y_28,m);
        {8}event begin(X_27,Y_28,m);
        {9}out(cAO, (X_27,Y_28,m));
        {10}let x_29: bitstring = (m,Y_28) in
        {11}out(c, enc(k,(m,Y_28)))
) | (
    {12}in(c, (X_30: host,Y_31: host));
    {13}if ((Y_31 <> A) && (Y_31 <> B)) then
        0
    else
        {14}in(c, y_32: bitstring);
        {15}let (x_33: bitstring,=Y_31) = dec(k,y_32) in
        {16}event received(X_30,Y_31,x_33);
        {17}out(cBO, (X_30,Y_31,x_33));
        {18}if ((X_30 = A) || (X_30 = B)) then
        {19}event end(X_30,Y_31,x_33)
)

-- Query event(different(X_34,Y_35,N)) ==> (event(sent(X_34,Y_35,N)) && event(received(X_34,Y_35,N)))
Completing...
Starting query event(different(X_34,Y_35,N)) ==> (event(sent(X_34,Y_35,N)) && event(received(X_34,Y_35,N)))
RESULT event(different(X_34,Y_35,N)) ==> (event(sent(X_34,Y_35,N)) && event(received(X_34,Y_35,N))) is true.
-- Query event(end(X_889,Y_890,Z)) ==> event(begin(X_889,Y_890,Z))
Completing...
Starting query event(end(X_889,Y_890,Z)) ==> event(begin(X_889,Y_890,Z))
goal reachable: begin(begin(B[],B[],m[])) -> end(end(A[],B[],m[]))

1. The attacker initially knows B[].
attacker(B[]).

2. The attacker initially knows A[].
attacker(A[]).

3. By 2, the attacker may know A[].
By 1, the attacker may know B[].
Using the function 2-tuple the attacker may obtain (A[],B[]).
attacker((A[],B[])).

4. By 1, the attacker may know B[].
By 1, the attacker may know B[].
Using the function 2-tuple the attacker may obtain (B[],B[]).
attacker((B[],B[])).

5. The message (B[],B[]) that the attacker may have by 4 may be received at input {5}.
The event begin(B[],B[],m[]) may be executed at {8}.
So the message enc(k[],(m[],B[])) may be sent to the attacker at output {11}.
attacker(enc(k[],(m[],B[]))).

6. The message (A[],B[]) that the attacker may have by 3 may be received at input {12}.
The message enc(k[],(m[],B[])) that the attacker may have by 5 may be received at input {14}.
So event end(A[],B[],m[]) may be executed at {19}.
end(end(A[],B[],m[])).


A more detailed output of the traces is available with
  set traceDisplay = long.

in(c, (B,B)) at {5}

event(sent(B,B,m)) at {7}

event(begin(B,B,m)) at {8}

out(cAO, (B,B,m)) at {9} received at {1}

out(c, enc(k,(m,B))) at {11}

in(c, (A,B)) at {12}

in(c, enc(k,(m,B))) at {14}

event(received(A,B,m)) at {16}

out(cBO, (A,B,m)) at {17} received at {2} (input fails)

event(end(A,B,m)) at {19}

The event end(A,B,m) is executed.
A trace has been found.
RESULT event(end(X_889,Y_890,Z)) ==> event(begin(X_889,Y_890,Z)) is false.
