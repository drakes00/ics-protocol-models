Process:
(
    {1}in(cAO, (X: host,Y: host,m1: bitstring));
    {2}in(cBO, (=X,=Y,m2: bitstring));
    {3}if (m1 = m2) then
        0
    else
        {4}event different(X,Y,m2)
) | (
    {5}in(c, (X_22: host,Y_23: host));
    {6}if ((X_22 <> A) && (X_22 <> B)) then
        0
    else
        {7}event sent(X_22,Y_23,m);
        {8}event begin(X_22,Y_23,m);
        {9}out(cAO, (X_22,Y_23,m));
        {10}out(c, (m,H(k,m)))
) | (
    {11}in(c, (X_24: host,Y_25: host));
    {12}if ((Y_25 <> A) && (Y_25 <> B)) then
        0
    else
        {13}in(c, (x: bitstring,h: bitstring));
        {14}if (h <> H(k,x)) then
            0
        else
            {15}event received(X_24,Y_25,x);
            {16}out(cBO, (X_24,Y_25,x));
            {17}if ((X_24 = A) || (X_24 = B)) then
            {18}event end(X_24,Y_25,x)
)

-- Query event(different(X_26,Y_27,N)) ==> (event(sent(X_26,Y_27,N)) && event(received(X_26,Y_27,N)))
Completing...
Starting query event(different(X_26,Y_27,N)) ==> (event(sent(X_26,Y_27,N)) && event(received(X_26,Y_27,N)))
RESULT event(different(X_26,Y_27,N)) ==> (event(sent(X_26,Y_27,N)) && event(received(X_26,Y_27,N))) is true.
-- Query event(end(X_984,Y_985,Z)) ==> event(begin(X_984,Y_985,Z))
Completing...
Starting query event(end(X_984,Y_985,Z)) ==> event(begin(X_984,Y_985,Z))
goal reachable: begin(begin(B[],Y_1992,m[])) && attacker(Y_1992) -> end(end(B[],A[],m[]))

1. The attacker initially knows A[].
attacker(A[]).

2. The attacker initially knows B[].
attacker(B[]).

3. By 2, the attacker may know B[].
By 1, the attacker may know A[].
Using the function 2-tuple the attacker may obtain (B[],A[]).
attacker((B[],A[])).

4. We assume as hypothesis that
attacker(Y_2018).

5. By 2, the attacker may know B[].
By 4, the attacker may know Y_2018.
Using the function 2-tuple the attacker may obtain (B[],Y_2018).
attacker((B[],Y_2018)).

6. The message (B[],Y_2018) that the attacker may have by 5 may be received at input {5}.
The event begin(B[],Y_2018,m[]) may be executed at {8}.
So the message (m[],H(k[],m[])) may be sent to the attacker at output {10}.
attacker((m[],H(k[],m[]))).

7. By 6, the attacker may know (m[],H(k[],m[])).
Using the function 2-proj-2-tuple the attacker may obtain H(k[],m[]).
attacker(H(k[],m[])).

8. By 6, the attacker may know (m[],H(k[],m[])).
Using the function 1-proj-2-tuple the attacker may obtain m[].
attacker(m[]).

9. By 8, the attacker may know m[].
By 7, the attacker may know H(k[],m[]).
Using the function 2-tuple the attacker may obtain (m[],H(k[],m[])).
attacker((m[],H(k[],m[]))).

10. The message (B[],A[]) that the attacker may have by 3 may be received at input {11}.
The message (m[],H(k[],m[])) that the attacker may have by 9 may be received at input {13}.
So event end(B[],A[],m[]) may be executed at {18}.
end(end(B[],A[],m[])).


A more detailed output of the traces is available with
  set traceDisplay = long.

in(c, (B,a)) at {5}

event(sent(B,a,m)) at {7}

event(begin(B,a,m)) at {8}

out(cAO, (B,a,m)) at {9} received at {1}

out(c, (m,H(k,m))) at {10}

in(c, (B,A)) at {11}

in(c, (m,H(k,m))) at {13}

event(received(B,A,m)) at {15}

out(cBO, (B,A,m)) at {16} received at {2} (input fails)

event(end(B,A,m)) at {18}

The event end(B,A,m) is executed.
A trace has been found.
RESULT event(end(X_984,Y_985,Z)) ==> event(begin(X_984,Y_985,Z)) is false.
