File "sign.pv", line 41, character 9 - line 41, character 11:
Warning: identifier sk rebound
Process:
{1}out(c, pub(skA));
{2}out(c, pub(skB));
(
    {3}in(cAO, (X: host,Y: host,m1: bitstring));
    {4}in(cBO, (=X,=Y,m2: bitstring));
    {5}if (m1 = m2) then
        0
    else
        {6}event different(X,Y,m2)
) | (
    {7}in(c, (X_45: host,Y_46: host));
    {8}if ((X_45 <> A) && (X_45 <> B)) then
        0
    else
        {9}let sk_47: bitstring = (if (X_45 = A) then skA else (if (X_45 = B) then skB else sk(X_45))) in
        {10}event sent(X_45,Y_46,m);
        {11}event begin(X_45,Y_46,m);
        {12}out(cAO, (X_45,Y_46,m));
        {13}out(c, (m,sign(sk_47,m)))
) | (
    {14}in(c, (X_48: host,Y_49: host));
    {15}if ((Y_49 <> A) && (Y_49 <> B)) then
        0
    else
        {16}let pk: bitstring = (if (X_48 = A) then pub(skA) else (if (X_48 = B) then pub(skB) else pub(sk(X_48)))) in
        {17}in(c, (x_50: bitstring,sX: bitstring));
        {18}if (verify(pk,sX,x_50) <> true) then
            0
        else
            {19}event received(X_48,Y_49,x_50);
            {20}out(cBO, (X_48,Y_49,x_50));
            {21}if ((X_48 = A) || (X_48 = B)) then
            {22}event end(X_48,Y_49,x_50)
)

-- Query event(different(X_51,Y_52,N)) ==> (event(sent(X_51,Y_52,N)) && event(received(X_51,Y_52,N)))
Completing...
Starting query event(different(X_51,Y_52,N)) ==> (event(sent(X_51,Y_52,N)) && event(received(X_51,Y_52,N)))
RESULT event(different(X_51,Y_52,N)) ==> (event(sent(X_51,Y_52,N)) && event(received(X_51,Y_52,N))) is true.
-- Query event(end(X_1983,Y_1984,Z)) ==> event(begin(X_1983,Y_1984,Z))
Completing...
Starting query event(end(X_1983,Y_1984,Z)) ==> event(begin(X_1983,Y_1984,Z))
goal reachable: begin(begin(B[],Y_3887,m[])) && attacker(Y_3887) -> end(end(B[],A[],m[]))

1. The attacker initially knows A[].
attacker(A[]).

2. The attacker initially knows B[].
attacker(B[]).

3. By 2, the attacker may know B[].
By 1, the attacker may know A[].
Using the function 2-tuple the attacker may obtain (B[],A[]).
attacker((B[],A[])).

4. We assume as hypothesis that
attacker(Y_3901).

5. By 2, the attacker may know B[].
By 4, the attacker may know Y_3901.
Using the function 2-tuple the attacker may obtain (B[],Y_3901).
attacker((B[],Y_3901)).

6. The message (B[],Y_3901) that the attacker may have by 5 may be received at input {7}.
The event begin(B[],Y_3901,m[]) may be executed at {11}.
So the message (m[],sign(skB[],m[])) may be sent to the attacker at output {13}.
attacker((m[],sign(skB[],m[]))).

7. By 6, the attacker may know (m[],sign(skB[],m[])).
Using the function 2-proj-2-tuple the attacker may obtain sign(skB[],m[]).
attacker(sign(skB[],m[])).

8. By 6, the attacker may know (m[],sign(skB[],m[])).
Using the function 1-proj-2-tuple the attacker may obtain m[].
attacker(m[]).

9. By 8, the attacker may know m[].
By 7, the attacker may know sign(skB[],m[]).
Using the function 2-tuple the attacker may obtain (m[],sign(skB[],m[])).
attacker((m[],sign(skB[],m[]))).

10. The message (B[],A[]) that the attacker may have by 3 may be received at input {14}.
The message (m[],sign(skB[],m[])) that the attacker may have by 9 may be received at input {17}.
So event end(B[],A[],m[]) may be executed at {22}.
end(end(B[],A[],m[])).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, pub(skA)) at {1}

out(c, pub(skB)) at {2}

in(c, (B,a)) at {7}

event(sent(B,a,m)) at {10}

event(begin(B,a,m)) at {11}

out(cAO, (B,a,m)) at {12} received at {3}

out(c, (m,sign(skB,m))) at {13}

in(c, (B,A)) at {14}

in(c, (m,sign(skB,m))) at {17}

event(received(B,A,m)) at {19}

out(cBO, (B,A,m)) at {20} received at {4} (input fails)

event(end(B,A,m)) at {22}

The event end(B,A,m) is executed.
A trace has been found.
RESULT event(end(X_1983,Y_1984,Z)) ==> event(begin(X_1983,Y_1984,Z)) is false.
