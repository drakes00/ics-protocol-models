(*  Public key signature
    A -> B: m, {m}_skA
*)

free c: channel.

type host.
free A, B, C: host.

free cAO: channel [private].
free cBO: channel [private].

fun pub(bitstring): bitstring.

fun sign(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; verify(pub(y), sign(y, x), x) = true.

free skA: bitstring [private].
free m: bitstring [private].

event begin(host, host, bitstring).
event end(host, host, bitstring).
query X: host, Y: host, z: bitstring; event(end(X, Y, z)) ==> event(begin(X, Y, z)).

event different(bitstring, bitstring).
query x: bitstring ; event(different(m, x)).
query x: bitstring ; event(different(x, m)).

let oracle = in(cAO, m1: bitstring); in(cBO, m2: bitstring); if m1 = m2 then 0 else event different(m1, m2).

let alice = out(cAO, m); event begin(A, B, m); out(c, (m, sign(skA, m))).
let bob = in(c, (x: bitstring, y: bitstring)); if verify(pub(skA), y, x) = true then out(cBO, x); event end(A, B, x) else 0.

process out(c, pub(skA)); oracle | alice | bob
