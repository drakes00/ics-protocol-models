Linear part:
exp(exp(g,x_32),y) = exp(exp(g,y),x_32)
Completing equations...
Completed equations:
exp(exp(g,x_32),y) = exp(exp(g,y),x_32)
Convergent part:
Completing equations...
Completed equations:
Process:
{1}let pkA: bitstring = pub(skA) in
{2}out(c, pkA);
{3}let pkB: bitstring = pub(skB) in
{4}out(c, pkB);
{5}let pkC: bitstring = pub(skC) in
{6}out(c, pkC);
(
    {7}!
    {8}in(c, (Cli: host,Disco: host,Sess: host));
    {9}let skCli: bitstring = (if (Cli = A) then skA else (if (Cli = B) then skB else (if (Cli = C) then skC else fail-any))) in
    {10}let pkCli: bitstring = pub(skCli) in
    {11}let pkDisco: bitstring = (if (Disco = A) then pub(skA) else (if (Disco = B) then pub(skB) else (if (Disco = C) then pub(skC) else pub(sk(Disco))))) in
    {12}let pkSess: bitstring = (if (Sess = A) then pub(skA) else (if (Sess = B) then pub(skB) else (if (Sess = C) then pub(skC) else pub(sk(Sess))))) in
    {13}out(c, GetEndpointRequest);
    {14}in(c, (SPs: bitstring,=SignAndEncrypt,UP: bitstring,=pkSess));
    {15}new SPc: bitstring;
    {16}new Nc: bitstring;
    {17}let gNc: bitstring = exp(g,Nc) in
    {18}let m1: bitstring = (SPc,gNc) in
    {19}event beginCli(Cli,Sess,gNc);
    {20}out(c, (pkCli,enc(m1,pkSess),sign(h(m1),skCli)));
    {21}in(c, (ePartS: bitstring,sigPartS: bitstring));
    {22}let PartS: bitstring = dec(ePartS,skCli) in
    {23}if (verify(h(PartS),sigPartS,pkSess) <> true) then
        0
    else
        {24}if ((Sess = A) || ((Sess = B) || (Sess = C))) then
        {25}event endCli(Sess,Cli,PartS)
) | (
    {26}!
    {27}in(c, (Cli_84: host,Disco_85: host,Sess_86: host));
    {28}let skDisco: bitstring = (if (Disco_85 = A) then skA else (if (Disco_85 = B) then skB else (if (Disco_85 = C) then skC else fail-any))) in
    {29}let pkDisco_87: bitstring = pub(skDisco) in
    {30}let pkCli_88: bitstring = (if (Cli_84 = A) then pub(skA) else (if (Cli_84 = B) then pub(skB) else (if (Cli_84 = C) then pub(skC) else pub(sk(Cli_84))))) in
    {31}let pkSess_89: bitstring = (if (Sess_86 = A) then pub(skA) else (if (Sess_86 = B) then pub(skB) else (if (Sess_86 = C) then pub(skC) else pub(sk(Sess_86))))) in
    {32}in(c, =GetEndpointRequest);
    {33}new SPs_90: bitstring;
    {34}new UP_91: bitstring;
    {35}out(c, (SPs_90,None,UP_91,pkSess_89))
) | (
    {36}!
    {37}in(c, (Cli_92: host,Disco_93: host,Sess_94: host));
    {38}let skSess: bitstring = (if (Sess_94 = A) then skA else (if (Sess_94 = B) then skB else (if (Sess_94 = C) then skC else fail-any))) in
    {39}let pkSess_95: bitstring = pub(skSess) in
    {40}let pkCli_96: bitstring = (if (Cli_92 = A) then pub(skA) else (if (Cli_92 = B) then pub(skB) else (if (Cli_92 = C) then pub(skC) else pub(sk(Cli_92))))) in
    {41}let pkDisco_97: bitstring = (if (Disco_93 = A) then pub(skA) else (if (Disco_93 = B) then pub(skB) else (if (Disco_93 = C) then pub(skC) else pub(sk(Disco_93))))) in
    {42}in(c, (=pkCli_96,m1_98: bitstring));
    {43}let (SPc_99: bitstring,PartC: bitstring) = m1_98 in
    {44}new Ns: bitstring;
    {45}let gNs: bitstring = exp(g,Ns) in
    {46}let m2: bitstring = gNs in
    {47}event beginSrv(Sess_94,Cli_92,gNs);
    {48}out(c, m2);
    {49}if ((Cli_92 = A) || ((Cli_92 = B) || (Cli_92 = C))) then
    {50}event endSrv(Cli_92,Sess_94,PartC)
)

-- Query event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N))
Completing...
200 rules inserted. The rule base contains 75 rules. 253 rules in the queue.
400 rules inserted. The rule base contains 96 rules. 253 rules in the queue.
600 rules inserted. The rule base contains 72 rules. 250 rules in the queue.
800 rules inserted. The rule base contains 92 rules. 231 rules in the queue.
1000 rules inserted. The rule base contains 183 rules. 197 rules in the queue.
1200 rules inserted. The rule base contains 335 rules. 305 rules in the queue.
1400 rules inserted. The rule base contains 493 rules. 270 rules in the queue.
1600 rules inserted. The rule base contains 638 rules. 218 rules in the queue.
1800 rules inserted. The rule base contains 755 rules. 166 rules in the queue.
2000 rules inserted. The rule base contains 856 rules. 108 rules in the queue.
2200 rules inserted. The rule base contains 925 rules. 44 rules in the queue.
Starting query event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N))
goal reachable: Sess_54560 <> C[] && Sess_54560 <> B[] && Sess_54560 <> A[] && attacker(SPs_54558) && attacker(UP_54559) && attacker(Sess_54560) -> end(endCli(C[],B[],(SPc[UP = UP_54559,SPs = SPs_54558,Sess = Sess_54560,Disco = B[],Cli = C[],!1 = @sid_54561],exp(g,Nc[UP = UP_54559,SPs = SPs_54558,Sess = Sess_54560,Disco = B[],Cli = C[],!1 = @sid_54561]))))
Abbreviations:
SPc_55845 = SPc[UP = UP_55821,SPs = SPs_55820,Sess = Sess_55822,Disco = B[],Cli = C[],!1 = @sid_55823]
Nc_55846 = Nc[UP = UP_55821,SPs = SPs_55820,Sess = Sess_55822,Disco = B[],Cli = C[],!1 = @sid_55823]

1. The attacker initially knows C[].
attacker(C[]).

2. The attacker initially knows B[].
attacker(B[]).

3. By 2, the attacker may know B[].
By 2, the attacker may know B[].
By 1, the attacker may know C[].
Using the function 3-tuple the attacker may obtain (B[],B[],C[]).
attacker((B[],B[],C[])).

4. The message pub(skC[]) may be sent to the attacker at output {6}.
attacker(pub(skC[])).

5. The attacker has some term UP_55840.
attacker(UP_55840).

6. Using the function SignAndEncrypt the attacker may obtain SignAndEncrypt.
attacker(SignAndEncrypt).

7. The attacker has some term SPs_55839.
attacker(SPs_55839).

8. By 7, the attacker may know SPs_55839.
By 6, the attacker may know SignAndEncrypt.
By 5, the attacker may know UP_55840.
By 4, the attacker may know pub(skC[]).
Using the function 4-tuple the attacker may obtain (SPs_55839,SignAndEncrypt,UP_55840,pub(skC[])).
attacker((SPs_55839,SignAndEncrypt,UP_55840,pub(skC[]))).

9. We assume as hypothesis that
attacker(Sess_55822).

10. By 1, the attacker may know C[].
By 2, the attacker may know B[].
By 9, the attacker may know Sess_55822.
Using the function 3-tuple the attacker may obtain (C[],B[],Sess_55822).
attacker((C[],B[],Sess_55822)).

11. By 9, the attacker may know Sess_55822.
Using the function sk the attacker may obtain sk(Sess_55822).
attacker(sk(Sess_55822)).

12. By 11, the attacker may know sk(Sess_55822).
Using the function pub the attacker may obtain pub(sk(Sess_55822)).
attacker(pub(sk(Sess_55822))).

13. We assume as hypothesis that
attacker(UP_55821).

14. We assume as hypothesis that
attacker(SPs_55820).

15. By 14, the attacker may know SPs_55820.
By 6, the attacker may know SignAndEncrypt.
By 13, the attacker may know UP_55821.
By 12, the attacker may know pub(sk(Sess_55822)).
Using the function 4-tuple the attacker may obtain (SPs_55820,SignAndEncrypt,UP_55821,pub(sk(Sess_55822))).
attacker((SPs_55820,SignAndEncrypt,UP_55821,pub(sk(Sess_55822)))).

16. The message (C[],B[],Sess_55822) that the attacker may have by 10 may be received at input {8}.
The message (SPs_55820,SignAndEncrypt,UP_55821,pub(sk(Sess_55822))) that the attacker may have by 15 may be received at input {14}.
We have Sess_55822 <> C[] & Sess_55822 <> B[] & Sess_55822 <> A[].
So the message (pub(skC[]),enc((SPc_55845,exp(g,Nc_55846)),pub(sk(Sess_55822))),sign(h((SPc_55845,exp(g,Nc_55846))),skC[])) may be sent to the attacker at output {20}.
attacker((pub(skC[]),enc((SPc_55845,exp(g,Nc_55846)),pub(sk(Sess_55822))),sign(h((SPc_55845,exp(g,Nc_55846))),skC[]))).

17. By 16, the attacker may know (pub(skC[]),enc((SPc_55845,exp(g,Nc_55846)),pub(sk(Sess_55822))),sign(h((SPc_55845,exp(g,Nc_55846))),skC[])).
Using the function 3-proj-3-tuple the attacker may obtain sign(h((SPc_55845,exp(g,Nc_55846))),skC[]).
attacker(sign(h((SPc_55845,exp(g,Nc_55846))),skC[])).

18. The message pub(skB[]) may be sent to the attacker at output {4}.
attacker(pub(skB[])).

19. By 16, the attacker may know (pub(skC[]),enc((SPc_55845,exp(g,Nc_55846)),pub(sk(Sess_55822))),sign(h((SPc_55845,exp(g,Nc_55846))),skC[])).
Using the function 2-proj-3-tuple the attacker may obtain enc((SPc_55845,exp(g,Nc_55846)),pub(sk(Sess_55822))).
attacker(enc((SPc_55845,exp(g,Nc_55846)),pub(sk(Sess_55822)))).

20. By 19, the attacker may know enc((SPc_55845,exp(g,Nc_55846)),pub(sk(Sess_55822))).
By 11, the attacker may know sk(Sess_55822).
Using the function dec the attacker may obtain (SPc_55845,exp(g,Nc_55846)).
attacker((SPc_55845,exp(g,Nc_55846))).

21. By 20, the attacker may know (SPc_55845,exp(g,Nc_55846)).
Using the function 2-proj-2-tuple the attacker may obtain exp(g,Nc_55846).
attacker(exp(g,Nc_55846)).

22. By 20, the attacker may know (SPc_55845,exp(g,Nc_55846)).
Using the function 1-proj-2-tuple the attacker may obtain SPc_55845.
attacker(SPc_55845).

23. By 22, the attacker may know SPc_55845.
By 21, the attacker may know exp(g,Nc_55846).
Using the function 2-tuple the attacker may obtain (SPc_55845,exp(g,Nc_55846)).
attacker((SPc_55845,exp(g,Nc_55846))).

24. By 23, the attacker may know (SPc_55845,exp(g,Nc_55846)).
By 18, the attacker may know pub(skB[]).
Using the function enc the attacker may obtain enc((SPc_55845,exp(g,Nc_55846)),pub(skB[])).
attacker(enc((SPc_55845,exp(g,Nc_55846)),pub(skB[]))).

25. By 24, the attacker may know enc((SPc_55845,exp(g,Nc_55846)),pub(skB[])).
By 17, the attacker may know sign(h((SPc_55845,exp(g,Nc_55846))),skC[]).
Using the function 2-tuple the attacker may obtain (enc((SPc_55845,exp(g,Nc_55846)),pub(skB[])),sign(h((SPc_55845,exp(g,Nc_55846))),skC[])).
attacker((enc((SPc_55845,exp(g,Nc_55846)),pub(skB[])),sign(h((SPc_55845,exp(g,Nc_55846))),skC[]))).

26. The message (B[],B[],C[]) that the attacker may have by 3 may be received at input {8}.
The message (SPs_55839,SignAndEncrypt,UP_55840,pub(skC[])) that the attacker may have by 8 may be received at input {14}.
The message (enc((SPc_55845,exp(g,Nc_55846)),pub(skB[])),sign(h((SPc_55845,exp(g,Nc_55846))),skC[])) that the attacker may have by 25 may be received at input {21}.
So event endCli(C[],B[],(SPc_55845,exp(g,Nc_55846))) may be executed at {25}.
end(endCli(C[],B[],(SPc_55845,exp(g,Nc_55846)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, pub(skA)) at {2}

out(c, pub(skB)) at {4}

out(c, pub(skC)) at {6}

in(c, (C,B,a_55848)) at {8} in copy a_55849

out(c, GetEndpointRequest) at {13} in copy a_55849

in(c, (a_55847,SignAndEncrypt,a,pub(sk(a_55848)))) at {14} in copy a_55849

new SPc creating SPc_55853 at {15} in copy a_55849

new Nc creating Nc_55854 at {16} in copy a_55849

event(beginCli(C,a_55848,exp(g,Nc_55854))) at {19} in copy a_55849

out(c, (pub(skC),enc((SPc_55853,exp(g,Nc_55854)),pub(sk(a_55848))),sign(h((SPc_55853,exp(g,Nc_55854))),skC))) at {20} in copy a_55849

in(c, (B,B,C)) at {8} in copy a_55852

out(c, GetEndpointRequest) at {13} in copy a_55852

in(c, (a_55850,SignAndEncrypt,a_55851,pub(skC))) at {14} in copy a_55852

new SPc creating SPc_56232 at {15} in copy a_55852

new Nc creating Nc_56233 at {16} in copy a_55852

event(beginCli(B,C,exp(g,Nc_56233))) at {19} in copy a_55852

out(c, (pub(skB),enc((SPc_56232,exp(g,Nc_56233)),pub(skC)),sign(h((SPc_56232,exp(g,Nc_56233))),skB))) at {20} in copy a_55852

in(c, (enc((SPc_55853,exp(g,Nc_55854)),pub(skB)),sign(h((SPc_55853,exp(g,Nc_55854))),skC))) at {21} in copy a_55852

event(endCli(C,B,(SPc_55853,exp(g,Nc_55854)))) at {25} in copy a_55852

The event endCli(C,B,(SPc_55853,exp(g,Nc_55854))) is executed.
A trace has been found.
RESULT event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N)) is false.
-- Query event(endSrv(X_56263,Y_56264,N_56265)) ==> event(beginCli(X_56263,Y_56264,N_56265))
Completing...
200 rules inserted. The rule base contains 66 rules. 253 rules in the queue.
400 rules inserted. The rule base contains 78 rules. 251 rules in the queue.
600 rules inserted. The rule base contains 54 rules. 250 rules in the queue.
800 rules inserted. The rule base contains 77 rules. 222 rules in the queue.
1000 rules inserted. The rule base contains 175 rules. 154 rules in the queue.
1200 rules inserted. The rule base contains 343 rules. 76 rules in the queue.
Starting query event(endSrv(X_56263,Y_56264,N_56265)) ==> event(beginCli(X_56263,Y_56264,N_56265))
goal reachable: attacker(N_104643) -> end(endSrv(B[],C[],N_104643))

1. The attacker initially knows C[].
attacker(C[]).

2. The attacker initially knows B[].
attacker(B[]).

3. By 2, the attacker may know B[].
By 2, the attacker may know B[].
By 1, the attacker may know C[].
Using the function 3-tuple the attacker may obtain (B[],B[],C[]).
attacker((B[],B[],C[])).

4. We assume as hypothesis that
attacker(N_104667).

5. The attacker has some term SPc_104662.
attacker(SPc_104662).

6. By 5, the attacker may know SPc_104662.
By 4, the attacker may know N_104667.
Using the function 2-tuple the attacker may obtain (SPc_104662,N_104667).
attacker((SPc_104662,N_104667)).

7. The message pub(skB[]) may be sent to the attacker at output {4}.
attacker(pub(skB[])).

8. By 7, the attacker may know pub(skB[]).
By 6, the attacker may know (SPc_104662,N_104667).
Using the function 2-tuple the attacker may obtain (pub(skB[]),(SPc_104662,N_104667)).
attacker((pub(skB[]),(SPc_104662,N_104667))).

9. The message (B[],B[],C[]) that the attacker may have by 3 may be received at input {37}.
The message (pub(skB[]),(SPc_104662,N_104667)) that the attacker may have by 8 may be received at input {42}.
So event endSrv(B[],C[],N_104667) may be executed at {50}.
end(endSrv(B[],C[],N_104667)).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, pub(skA)) at {2}

out(c, pub(skB)) at {4}

out(c, pub(skC)) at {6}

in(c, (B,B,C)) at {37} in copy a_104670

in(c, (pub(skB),(a_104669,a_104668))) at {42} in copy a_104670

new Ns creating Ns_104895 at {44} in copy a_104670

event(beginSrv(C,B,exp(g,Ns_104895))) at {47} in copy a_104670

out(c, exp(g,Ns_104895)) at {48} in copy a_104670

event(endSrv(B,C,a_104668)) at {50} in copy a_104670

The event endSrv(B,C,a_104668) is executed.
A trace has been found.
RESULT event(endSrv(X_56263,Y_56264,N_56265)) ==> event(beginCli(X_56263,Y_56264,N_56265)) is false.
