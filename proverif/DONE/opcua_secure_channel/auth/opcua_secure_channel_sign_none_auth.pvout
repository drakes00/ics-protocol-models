Linear part:
exp(exp(g,x_32),y) = exp(exp(g,y),x_32)
Completing equations...
Completed equations:
exp(exp(g,x_32),y) = exp(exp(g,y),x_32)
Convergent part:
Completing equations...
Completed equations:
Process:
{1}let pkA: bitstring = pub(skA) in
{2}out(c, pkA);
{3}let pkB: bitstring = pub(skB) in
{4}out(c, pkB);
{5}let pkC: bitstring = pub(skC) in
{6}out(c, pkC);
(
    {7}!
    {8}in(c, (Cli: host,Disco: host,Sess: host));
    {9}let skCli: bitstring = (if (Cli = A) then skA else (if (Cli = B) then skB else (if (Cli = C) then skC else fail-any))) in
    {10}let pkCli: bitstring = pub(skCli) in
    {11}let pkDisco: bitstring = (if (Disco = A) then pub(skA) else (if (Disco = B) then pub(skB) else (if (Disco = C) then pub(skC) else pub(sk(Disco))))) in
    {12}let pkSess: bitstring = (if (Sess = A) then pub(skA) else (if (Sess = B) then pub(skB) else (if (Sess = C) then pub(skC) else pub(sk(Sess))))) in
    {13}out(c, GetEndpointRequest);
    {14}in(c, (SPs: bitstring,=Sign,UP: bitstring,=pkSess));
    {15}new SPc: bitstring;
    {16}new Nc: bitstring;
    {17}let gNc: bitstring = exp(g,Nc) in
    {18}let m1: bitstring = (SPc,gNc) in
    {19}event beginCli(Cli,Sess,gNc);
    {20}out(c, (pkCli,m1,sign(h(m1),skCli)));
    {21}in(c, (PartS: bitstring,sigPartS: bitstring));
    {22}if (verify(h(PartS),sigPartS,pkSess) <> true) then
        0
    else
        {23}if ((Sess = A) || ((Sess = B) || (Sess = C))) then
        {24}event endCli(Sess,Cli,PartS)
) | (
    {25}!
    {26}in(c, (Cli_84: host,Disco_85: host,Sess_86: host));
    {27}let skDisco: bitstring = (if (Disco_85 = A) then skA else (if (Disco_85 = B) then skB else (if (Disco_85 = C) then skC else fail-any))) in
    {28}let pkDisco_87: bitstring = pub(skDisco) in
    {29}let pkCli_88: bitstring = (if (Cli_84 = A) then pub(skA) else (if (Cli_84 = B) then pub(skB) else (if (Cli_84 = C) then pub(skC) else pub(sk(Cli_84))))) in
    {30}let pkSess_89: bitstring = (if (Sess_86 = A) then pub(skA) else (if (Sess_86 = B) then pub(skB) else (if (Sess_86 = C) then pub(skC) else pub(sk(Sess_86))))) in
    {31}in(c, =GetEndpointRequest);
    {32}new SPs_90: bitstring;
    {33}new UP_91: bitstring;
    {34}out(c, (SPs_90,None,UP_91,pkSess_89))
) | (
    {35}!
    {36}in(c, (Cli_92: host,Disco_93: host,Sess_94: host));
    {37}let skSess: bitstring = (if (Sess_94 = A) then skA else (if (Sess_94 = B) then skB else (if (Sess_94 = C) then skC else fail-any))) in
    {38}let pkSess_95: bitstring = pub(skSess) in
    {39}let pkCli_96: bitstring = (if (Cli_92 = A) then pub(skA) else (if (Cli_92 = B) then pub(skB) else (if (Cli_92 = C) then pub(skC) else pub(sk(Cli_92))))) in
    {40}let pkDisco_97: bitstring = (if (Disco_93 = A) then pub(skA) else (if (Disco_93 = B) then pub(skB) else (if (Disco_93 = C) then pub(skC) else pub(sk(Disco_93))))) in
    {41}in(c, (=pkCli_96,m1_98: bitstring));
    {42}let (SPc_99: bitstring,PartC: bitstring) = m1_98 in
    {43}new Ns: bitstring;
    {44}let gNs: bitstring = exp(g,Ns) in
    {45}let m2: bitstring = gNs in
    {46}event beginSrv(Sess_94,Cli_92,gNs);
    {47}out(c, m2);
    {48}if ((Cli_92 = A) || ((Cli_92 = B) || (Cli_92 = C))) then
    {49}event endSrv(Cli_92,Sess_94,PartC)
)

-- Query event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N))
Completing...
200 rules inserted. The rule base contains 87 rules. 301 rules in the queue.
400 rules inserted. The rule base contains 99 rules. 301 rules in the queue.
600 rules inserted. The rule base contains 99 rules. 299 rules in the queue.
800 rules inserted. The rule base contains 53 rules. 296 rules in the queue.
1000 rules inserted. The rule base contains 91 rules. 271 rules in the queue.
1200 rules inserted. The rule base contains 194 rules. 206 rules in the queue.
1400 rules inserted. The rule base contains 337 rules. 198 rules in the queue.
1600 rules inserted. The rule base contains 429 rules. 159 rules in the queue.
1800 rules inserted. The rule base contains 444 rules. 144 rules in the queue.
2000 rules inserted. The rule base contains 444 rules. 144 rules in the queue.
2200 rules inserted. The rule base contains 454 rules. 134 rules in the queue.
2400 rules inserted. The rule base contains 545 rules. 43 rules in the queue.
Starting query event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N))
goal reachable: Sess_59039 <> C[] && Sess_59039 <> B[] && Sess_59039 <> A[] && attacker(SPs_59037) && attacker(UP_59038) && attacker(Sess_59039) -> end(endCli(C[],A[],(SPc[UP = UP_59038,SPs = SPs_59037,Sess = Sess_59039,Disco = B[],Cli = C[],!1 = @sid_59040],exp(g,Nc[UP = UP_59038,SPs = SPs_59037,Sess = Sess_59039,Disco = B[],Cli = C[],!1 = @sid_59040]))))
Abbreviations:
SPc_61990 = SPc[UP = UP_61968,SPs = SPs_61967,Sess = Sess_61969,Disco = B[],Cli = C[],!1 = @sid_61970]
Nc_61991 = Nc[UP = UP_61968,SPs = SPs_61967,Sess = Sess_61969,Disco = B[],Cli = C[],!1 = @sid_61970]

1. The attacker initially knows C[].
attacker(C[]).

2. The attacker initially knows A[].
attacker(A[]).

3. By 2, the attacker may know A[].
By 2, the attacker may know A[].
By 1, the attacker may know C[].
Using the function 3-tuple the attacker may obtain (A[],A[],C[]).
attacker((A[],A[],C[])).

4. The message pub(skC[]) may be sent to the attacker at output {6}.
attacker(pub(skC[])).

5. The attacker has some term UP_61985.
attacker(UP_61985).

6. Using the function Sign the attacker may obtain Sign.
attacker(Sign).

7. The attacker has some term SPs_61984.
attacker(SPs_61984).

8. By 7, the attacker may know SPs_61984.
By 6, the attacker may know Sign.
By 5, the attacker may know UP_61985.
By 4, the attacker may know pub(skC[]).
Using the function 4-tuple the attacker may obtain (SPs_61984,Sign,UP_61985,pub(skC[])).
attacker((SPs_61984,Sign,UP_61985,pub(skC[]))).

9. We assume as hypothesis that
attacker(Sess_61969).

10. The attacker initially knows B[].
attacker(B[]).

11. By 1, the attacker may know C[].
By 10, the attacker may know B[].
By 9, the attacker may know Sess_61969.
Using the function 3-tuple the attacker may obtain (C[],B[],Sess_61969).
attacker((C[],B[],Sess_61969)).

12. By 9, the attacker may know Sess_61969.
Using the function sk the attacker may obtain sk(Sess_61969).
attacker(sk(Sess_61969)).

13. By 12, the attacker may know sk(Sess_61969).
Using the function pub the attacker may obtain pub(sk(Sess_61969)).
attacker(pub(sk(Sess_61969))).

14. We assume as hypothesis that
attacker(UP_61968).

15. We assume as hypothesis that
attacker(SPs_61967).

16. By 15, the attacker may know SPs_61967.
By 6, the attacker may know Sign.
By 14, the attacker may know UP_61968.
By 13, the attacker may know pub(sk(Sess_61969)).
Using the function 4-tuple the attacker may obtain (SPs_61967,Sign,UP_61968,pub(sk(Sess_61969))).
attacker((SPs_61967,Sign,UP_61968,pub(sk(Sess_61969)))).

17. The message (C[],B[],Sess_61969) that the attacker may have by 11 may be received at input {8}.
The message (SPs_61967,Sign,UP_61968,pub(sk(Sess_61969))) that the attacker may have by 16 may be received at input {14}.
We have Sess_61969 <> C[] & Sess_61969 <> B[] & Sess_61969 <> A[].
So the message (pub(skC[]),(SPc_61990,exp(g,Nc_61991)),sign(h((SPc_61990,exp(g,Nc_61991))),skC[])) may be sent to the attacker at output {20}.
attacker((pub(skC[]),(SPc_61990,exp(g,Nc_61991)),sign(h((SPc_61990,exp(g,Nc_61991))),skC[]))).

18. By 17, the attacker may know (pub(skC[]),(SPc_61990,exp(g,Nc_61991)),sign(h((SPc_61990,exp(g,Nc_61991))),skC[])).
Using the function 3-proj-3-tuple the attacker may obtain sign(h((SPc_61990,exp(g,Nc_61991))),skC[]).
attacker(sign(h((SPc_61990,exp(g,Nc_61991))),skC[])).

19. By 17, the attacker may know (pub(skC[]),(SPc_61990,exp(g,Nc_61991)),sign(h((SPc_61990,exp(g,Nc_61991))),skC[])).
Using the function 2-proj-3-tuple the attacker may obtain (SPc_61990,exp(g,Nc_61991)).
attacker((SPc_61990,exp(g,Nc_61991))).

20. By 19, the attacker may know (SPc_61990,exp(g,Nc_61991)).
Using the function 2-proj-2-tuple the attacker may obtain exp(g,Nc_61991).
attacker(exp(g,Nc_61991)).

21. By 19, the attacker may know (SPc_61990,exp(g,Nc_61991)).
Using the function 1-proj-2-tuple the attacker may obtain SPc_61990.
attacker(SPc_61990).

22. By 21, the attacker may know SPc_61990.
By 20, the attacker may know exp(g,Nc_61991).
Using the function 2-tuple the attacker may obtain (SPc_61990,exp(g,Nc_61991)).
attacker((SPc_61990,exp(g,Nc_61991))).

23. By 22, the attacker may know (SPc_61990,exp(g,Nc_61991)).
By 18, the attacker may know sign(h((SPc_61990,exp(g,Nc_61991))),skC[]).
Using the function 2-tuple the attacker may obtain ((SPc_61990,exp(g,Nc_61991)),sign(h((SPc_61990,exp(g,Nc_61991))),skC[])).
attacker(((SPc_61990,exp(g,Nc_61991)),sign(h((SPc_61990,exp(g,Nc_61991))),skC[]))).

24. The message (A[],A[],C[]) that the attacker may have by 3 may be received at input {8}.
The message (SPs_61984,Sign,UP_61985,pub(skC[])) that the attacker may have by 8 may be received at input {14}.
The message ((SPc_61990,exp(g,Nc_61991)),sign(h((SPc_61990,exp(g,Nc_61991))),skC[])) that the attacker may have by 23 may be received at input {21}.
So event endCli(C[],A[],(SPc_61990,exp(g,Nc_61991))) may be executed at {24}.
end(endCli(C[],A[],(SPc_61990,exp(g,Nc_61991)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, pub(skA)) at {2}

out(c, pub(skB)) at {4}

out(c, pub(skC)) at {6}

in(c, (C,B,a_61993)) at {8} in copy a_61994

out(c, GetEndpointRequest) at {13} in copy a_61994

in(c, (a_61992,Sign,a,pub(sk(a_61993)))) at {14} in copy a_61994

new SPc creating SPc_61998 at {15} in copy a_61994

new Nc creating Nc_61999 at {16} in copy a_61994

event(beginCli(C,a_61993,exp(g,Nc_61999))) at {19} in copy a_61994

out(c, (pub(skC),(SPc_61998,exp(g,Nc_61999)),sign(h((SPc_61998,exp(g,Nc_61999))),skC))) at {20} in copy a_61994

in(c, (A,A,C)) at {8} in copy a_61997

out(c, GetEndpointRequest) at {13} in copy a_61997

in(c, (a_61995,Sign,a_61996,pub(skC))) at {14} in copy a_61997

new SPc creating SPc_62358 at {15} in copy a_61997

new Nc creating Nc_62359 at {16} in copy a_61997

event(beginCli(A,C,exp(g,Nc_62359))) at {19} in copy a_61997

out(c, (pub(skA),(SPc_62358,exp(g,Nc_62359)),sign(h((SPc_62358,exp(g,Nc_62359))),skA))) at {20} in copy a_61997

in(c, ((SPc_61998,exp(g,Nc_61999)),sign(h((SPc_61998,exp(g,Nc_61999))),skC))) at {21} in copy a_61997

event(endCli(C,A,(SPc_61998,exp(g,Nc_61999)))) at {24} in copy a_61997

The event endCli(C,A,(SPc_61998,exp(g,Nc_61999))) is executed.
A trace has been found.
RESULT event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N)) is false.
-- Query event(endSrv(X_62384,Y_62385,N_62386)) ==> event(beginCli(X_62384,Y_62385,N_62386))
Completing...
200 rules inserted. The rule base contains 78 rules. 301 rules in the queue.
400 rules inserted. The rule base contains 90 rules. 301 rules in the queue.
600 rules inserted. The rule base contains 89 rules. 299 rules in the queue.
800 rules inserted. The rule base contains 46 rules. 293 rules in the queue.
1000 rules inserted. The rule base contains 81 rules. 266 rules in the queue.
1200 rules inserted. The rule base contains 187 rules. 188 rules in the queue.
1400 rules inserted. The rule base contains 349 rules. 74 rules in the queue.
Starting query event(endSrv(X_62384,Y_62385,N_62386)) ==> event(beginCli(X_62384,Y_62385,N_62386))
goal reachable: attacker(N_113455) -> end(endSrv(B[],C[],N_113455))

1. The attacker initially knows C[].
attacker(C[]).

2. The attacker initially knows B[].
attacker(B[]).

3. By 2, the attacker may know B[].
By 2, the attacker may know B[].
By 1, the attacker may know C[].
Using the function 3-tuple the attacker may obtain (B[],B[],C[]).
attacker((B[],B[],C[])).

4. We assume as hypothesis that
attacker(N_113479).

5. The attacker has some term SPc_113474.
attacker(SPc_113474).

6. By 5, the attacker may know SPc_113474.
By 4, the attacker may know N_113479.
Using the function 2-tuple the attacker may obtain (SPc_113474,N_113479).
attacker((SPc_113474,N_113479)).

7. The message pub(skB[]) may be sent to the attacker at output {4}.
attacker(pub(skB[])).

8. By 7, the attacker may know pub(skB[]).
By 6, the attacker may know (SPc_113474,N_113479).
Using the function 2-tuple the attacker may obtain (pub(skB[]),(SPc_113474,N_113479)).
attacker((pub(skB[]),(SPc_113474,N_113479))).

9. The message (B[],B[],C[]) that the attacker may have by 3 may be received at input {36}.
The message (pub(skB[]),(SPc_113474,N_113479)) that the attacker may have by 8 may be received at input {41}.
So event endSrv(B[],C[],N_113479) may be executed at {49}.
end(endSrv(B[],C[],N_113479)).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, pub(skA)) at {2}

out(c, pub(skB)) at {4}

out(c, pub(skC)) at {6}

in(c, (B,B,C)) at {36} in copy a_113482

in(c, (pub(skB),(a_113481,a_113480))) at {41} in copy a_113482

new Ns creating Ns_113704 at {43} in copy a_113482

event(beginSrv(C,B,exp(g,Ns_113704))) at {46} in copy a_113482

out(c, exp(g,Ns_113704)) at {47} in copy a_113482

event(endSrv(B,C,a_113480)) at {49} in copy a_113482

The event endSrv(B,C,a_113480) is executed.
A trace has been found.
RESULT event(endSrv(X_62384,Y_62385,N_62386)) ==> event(beginCli(X_62384,Y_62385,N_62386)) is false.
