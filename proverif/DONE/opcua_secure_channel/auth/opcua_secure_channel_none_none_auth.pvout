Linear part:
exp(exp(g,x_32),y) = exp(exp(g,y),x_32)
Completing equations...
Completed equations:
exp(exp(g,x_32),y) = exp(exp(g,y),x_32)
Convergent part:
Completing equations...
Completed equations:
Process:
{1}let pkA: bitstring = pub(skA) in
{2}out(c, pkA);
{3}let pkB: bitstring = pub(skB) in
{4}out(c, pkB);
{5}let pkC: bitstring = pub(skC) in
{6}out(c, pkC);
(
    {7}!
    {8}in(c, (Cli: host,Disco: host,Sess: host));
    {9}let skCli: bitstring = (if (Cli = A) then skA else (if (Cli = B) then skB else (if (Cli = C) then skC else fail-any))) in
    {10}let pkCli: bitstring = pub(skCli) in
    {11}let pkDisco: bitstring = (if (Disco = A) then pub(skA) else (if (Disco = B) then pub(skB) else (if (Disco = C) then pub(skC) else pub(sk(Disco))))) in
    {12}let pkSess: bitstring = (if (Sess = A) then pub(skA) else (if (Sess = B) then pub(skB) else (if (Sess = C) then pub(skC) else pub(sk(Sess))))) in
    {13}out(c, GetEndpointRequest);
    {14}in(c, (SPs: bitstring,=None,UP: bitstring,=pkSess));
    {15}new SPc: bitstring;
    {16}new Nc: bitstring;
    {17}let gNc: bitstring = exp(g,Nc) in
    {18}event beginCli(Cli,Sess,gNc);
    {19}out(c, (pkCli,SPc,gNc));
    {20}in(c, PartS: bitstring);
    {21}if ((Sess = A) || ((Sess = B) || (Sess = C))) then
    {22}event endCli(Sess,Cli,PartS)
) | (
    {23}!
    {24}in(c, (Cli_81: host,Disco_82: host,Sess_83: host));
    {25}let skDisco: bitstring = (if (Disco_82 = A) then skA else (if (Disco_82 = B) then skB else (if (Disco_82 = C) then skC else fail-any))) in
    {26}let pkDisco_84: bitstring = pub(skDisco) in
    {27}let pkCli_85: bitstring = (if (Cli_81 = A) then pub(skA) else (if (Cli_81 = B) then pub(skB) else (if (Cli_81 = C) then pub(skC) else pub(sk(Cli_81))))) in
    {28}let pkSess_86: bitstring = (if (Sess_83 = A) then pub(skA) else (if (Sess_83 = B) then pub(skB) else (if (Sess_83 = C) then pub(skC) else pub(sk(Sess_83))))) in
    {29}in(c, =GetEndpointRequest);
    {30}new SPs_87: bitstring;
    {31}new UP_88: bitstring;
    {32}out(c, (SPs_87,None,UP_88,pkSess_86))
) | (
    {33}!
    {34}in(c, (Cli_89: host,Disco_90: host,Sess_91: host));
    {35}let skSess: bitstring = (if (Sess_91 = A) then skA else (if (Sess_91 = B) then skB else (if (Sess_91 = C) then skC else fail-any))) in
    {36}let pkSess_92: bitstring = pub(skSess) in
    {37}let pkCli_93: bitstring = (if (Cli_89 = A) then pub(skA) else (if (Cli_89 = B) then pub(skB) else (if (Cli_89 = C) then pub(skC) else pub(sk(Cli_89))))) in
    {38}let pkDisco_94: bitstring = (if (Disco_90 = A) then pub(skA) else (if (Disco_90 = B) then pub(skB) else (if (Disco_90 = C) then pub(skC) else pub(sk(Disco_90))))) in
    {39}in(c, (=pkCli_93,SPc_95: bitstring,PartC: bitstring));
    {40}new Ns: bitstring;
    {41}let gNs: bitstring = exp(g,Ns) in
    {42}event beginSrv(Sess_91,Cli_89,gNs);
    {43}out(c, gNs);
    {44}if ((Cli_89 = A) || ((Cli_89 = B) || (Cli_89 = C))) then
    {45}event endSrv(Cli_89,Sess_91,PartC)
)

-- Query event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N))
Completing...
200 rules inserted. The rule base contains 66 rules. 253 rules in the queue.
400 rules inserted. The rule base contains 78 rules. 253 rules in the queue.
600 rules inserted. The rule base contains 54 rules. 250 rules in the queue.
800 rules inserted. The rule base contains 75 rules. 223 rules in the queue.
1000 rules inserted. The rule base contains 168 rules. 152 rules in the queue.
1200 rules inserted. The rule base contains 338 rules. 44 rules in the queue.
Starting query event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N))
goal reachable: attacker(N_44693) -> end(endCli(B[],C[],N_44693))

1. The attacker initially knows B[].
attacker(B[]).

2. The attacker initially knows C[].
attacker(C[]).

3. By 2, the attacker may know C[].
By 1, the attacker may know B[].
By 1, the attacker may know B[].
Using the function 3-tuple the attacker may obtain (C[],B[],B[]).
attacker((C[],B[],B[])).

4. The message pub(skB[]) may be sent to the attacker at output {4}.
attacker(pub(skB[])).

5. The attacker has some term UP_44714.
attacker(UP_44714).

6. Using the function None the attacker may obtain None.
attacker(None).

7. The attacker has some term SPs_44713.
attacker(SPs_44713).

8. By 7, the attacker may know SPs_44713.
By 6, the attacker may know None.
By 5, the attacker may know UP_44714.
By 4, the attacker may know pub(skB[]).
Using the function 4-tuple the attacker may obtain (SPs_44713,None,UP_44714,pub(skB[])).
attacker((SPs_44713,None,UP_44714,pub(skB[]))).

9. We assume as hypothesis that
attacker(N_44718).

10. The message (C[],B[],B[]) that the attacker may have by 3 may be received at input {8}.
The message (SPs_44713,None,UP_44714,pub(skB[])) that the attacker may have by 8 may be received at input {14}.
The message N_44718 that the attacker may have by 9 may be received at input {20}.
So event endCli(B[],C[],N_44718) may be executed at {22}.
end(endCli(B[],C[],N_44718)).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, pub(skA)) at {2}

out(c, pub(skB)) at {4}

out(c, pub(skC)) at {6}

in(c, (C,B,B)) at {8} in copy a_44721

out(c, GetEndpointRequest) at {13} in copy a_44721

in(c, (a_44719,None,a_44720,pub(skB))) at {14} in copy a_44721

new SPc creating SPc_44920 at {15} in copy a_44721

new Nc creating Nc_44921 at {16} in copy a_44721

event(beginCli(C,B,exp(g,Nc_44921))) at {18} in copy a_44721

out(c, (pub(skC),SPc_44920,exp(g,Nc_44921))) at {19} in copy a_44721

in(c, a) at {20} in copy a_44721

event(endCli(B,C,a)) at {22} in copy a_44721

The event endCli(B,C,a) is executed.
A trace has been found.
RESULT event(endCli(X,Y,N)) ==> event(beginSrv(X,Y,N)) is false.
-- Query event(endSrv(X_44935,Y_44936,N_44937)) ==> event(beginCli(X_44935,Y_44936,N_44937))
Completing...
200 rules inserted. The rule base contains 66 rules. 253 rules in the queue.
400 rules inserted. The rule base contains 78 rules. 251 rules in the queue.
600 rules inserted. The rule base contains 54 rules. 250 rules in the queue.
800 rules inserted. The rule base contains 77 rules. 221 rules in the queue.
1000 rules inserted. The rule base contains 175 rules. 148 rules in the queue.
1200 rules inserted. The rule base contains 347 rules. 37 rules in the queue.
Starting query event(endSrv(X_44935,Y_44936,N_44937)) ==> event(beginCli(X_44935,Y_44936,N_44937))
goal reachable: attacker(N_90744) -> end(endSrv(B[],C[],N_90744))

1. The attacker initially knows C[].
attacker(C[]).

2. The attacker initially knows B[].
attacker(B[]).

3. By 2, the attacker may know B[].
By 2, the attacker may know B[].
By 1, the attacker may know C[].
Using the function 3-tuple the attacker may obtain (B[],B[],C[]).
attacker((B[],B[],C[])).

4. We assume as hypothesis that
attacker(N_90767).

5. The attacker has some term SPc_90762.
attacker(SPc_90762).

6. The message pub(skB[]) may be sent to the attacker at output {4}.
attacker(pub(skB[])).

7. By 6, the attacker may know pub(skB[]).
By 5, the attacker may know SPc_90762.
By 4, the attacker may know N_90767.
Using the function 3-tuple the attacker may obtain (pub(skB[]),SPc_90762,N_90767).
attacker((pub(skB[]),SPc_90762,N_90767)).

8. The message (B[],B[],C[]) that the attacker may have by 3 may be received at input {34}.
The message (pub(skB[]),SPc_90762,N_90767) that the attacker may have by 7 may be received at input {39}.
So event endSrv(B[],C[],N_90767) may be executed at {45}.
end(endSrv(B[],C[],N_90767)).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, pub(skA)) at {2}

out(c, pub(skB)) at {4}

out(c, pub(skC)) at {6}

in(c, (B,B,C)) at {34} in copy a_90770

in(c, (pub(skB),a_90769,a_90768)) at {39} in copy a_90770

new Ns creating Ns_90962 at {40} in copy a_90770

event(beginSrv(C,B,exp(g,Ns_90962))) at {42} in copy a_90770

out(c, exp(g,Ns_90962)) at {43} in copy a_90770

event(endSrv(B,C,a_90768)) at {45} in copy a_90770

The event endSrv(B,C,a_90768) is executed.
A trace has been found.
RESULT event(endSrv(X_44935,Y_44936,N_44937)) ==> event(beginCli(X_44935,Y_44936,N_44937)) is false.
