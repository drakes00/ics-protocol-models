(*  OpcUaClient --[CreateSessionRequest]--> SessionEndpoint
    SessionEndpoint --[SSC, Ns2]--> OpcUaClient
    OpcUaClient --[CSC, Login, Password]--> SessionEndpoint
    SessionEndpoint --[ActivateSessionResponse]--> OpcUaClient
*)

free c: channel.


(* Hosts *)
type host.
free A, B, I: host.


(* Hash function *)
fun h(bitstring): bitstring.


(* Symetric key crypto *)
fun senc(bitstring, bitstring): bitstring.
reduc forall x: bitstring, k: bitstring ; sdec(senc(x, k), k) = x.


(* Signatures *)
fun sk(host): bitstring.
fun pub(bitstring): bitstring.
fun sign(bitstring, bitstring): bitstring.
reduc forall x:bitstring, s:bitstring, k:bitstring ; verify(x, sign(x, k), pub(k)) = true.


(* Constants *)
const CreateSessionRequest: bitstring.
const ActivateSessionResponse: bitstring.


(* Private keys *)
free skA: bitstring [private].
free skB: bitstring [private].
fun Skey(bitstring, bitstring): bitstring [private].


(* Secrets *)
fun Login(bitstring): bitstring [private].
fun Passwd(bitstring): bitstring [private].


(* Events *)
event beginCli(host, host, bitstring).
event endSrv(host, host, bitstring).


(* Goals *)
query attacker(Login(skA)).
query attacker(Passwd(skA)).
query attacker(Skey(skA, skB)).
query attacker(Skey(skB, skA)).

query X: host, Y: host, N: bitstring ; event(endSrv(X, Y, N)) ==> event(beginCli(X, Y, N)).


let keyRegistration =
    in(c, (X: host, Y: host));
    let skX = if X = A then skA else if X = B then skB else sk(X) in
    let skY = if Y = A then skA else if Y = B then skB else sk(Y) in
    if (X, Y) = (A, B) then 0 else
    if (X, Y) = (B, A) then 0 else
    out(c, Skey(skX, skY)).


let client(skA: bitstring, skB: bitstring) = 
    in(c, (Cli: host, Sess: host));
    let skCli = if Cli = A then skA else if Cli = B then skB in
    let pkCli = pub(skCli) in
    let skSess = if Sess = A then skA else if Sess = B then skB else sk(Sess) in
    let pkSess = pub(skSess) in
    let K = Skey(skCli, skSess) in

    (* Role starting *)
    let m1 = CreateSessionRequest in
    out(c, (senc(m1, K), sign(h(m1), skCli)));

    in(c, (em2: bitstring, sigM2: bitstring));
    let m2 = sdec(em2, K) in
    if verify(h(m2), sigM2, pkSess) <> true then 0 else
    let (SSC: bitstring, Ns2: bitstring) = m2 in

    new CSC: bitstring;
    event beginCli(Cli, Sess, (Login(skCli), Passwd(skCli)));
    let m3 = (CSC, Login(skCli), Passwd(skCli)) in
    out(c, (senc(m3, K), sign(h(m3), skCli)));

    in(c, (em4: bitstring, sigM4: bitstring));
    let m4 = sdec(em4, K) in
    if verify(h(m4), sigM4, pkSess) <> true then 0 else
    if m4 <> ActivateSessionResponse then 0.


let sess(skA: bitstring, skB: bitstring) = 
    in(c, (Cli: host, Sess: host));
    let skCli = if Cli = A then skA else if Cli = B then skB else sk(Cli) in
    let pkCli = pub(skCli) in
    let skSess = if Sess = A then skA else if Sess = B then skB in
    let pkSess = pub(skSess) in
    let K = Skey(skCli, skSess) in

    (* Role starting *)
    in(c, (em1: bitstring, sigM1: bitstring));
    let m1 = sdec(em1, K) in
    if verify(h(m1), sigM1, pkCli) <> true then 0 else
    if m1 <> CreateSessionRequest then 0 else

    new SSC: bitstring;
    new Ns2: bitstring;
    let m2 = (SSC, Ns2) in
    out(c, (senc(m2, K), sign(h(m2), skSess)));

    in(c, (em3: bitstring, sigM3: bitstring));
    let m3 = sdec(em3, K) in
    if verify(h(m3), sigM3, pkCli) <> true then 0 else
    let (CSC: bitstring, =Login(skCli), =Passwd(skCli)) = m3 in
    event endSrv(Cli, Sess, (Login(skCli), Passwd(skCli)));
    
    let m4 = ActivateSessionResponse in
    out(c, (senc(m4, K), sign(h(m4), skSess))).


process
    let pkA = pub(skA) in out(c, pkA);
    let pkB = pub(skB) in out(c, pkB);

    (!client(skA, skB)  |
     !sess(skA, skB)    |
     !keyRegistration
    )
