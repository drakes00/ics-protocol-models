(*  OpcUaClient --[CreateSessionRequest]--> SessionEndpoint
    SessionEndpoint --[SSC, Ns2]--> OpcUaClient
    OpcUaClient --[CSC, Login, Password]--> SessionEndpoint
    SessionEndpoint --[ActivateSessionResponse]--> OpcUaClient
*)

free c: channel.


(* Hosts *)
type host.
free A, B, I: host.


(* Symetric key crypto *)
fun senc(bitstring, bitstring): bitstring.
reduc forall x: bitstring, k: bitstring ; sdec(senc(x, k), k) = x.


(* Signatures *)
fun pub(bitstring): bitstring.
fun sign(bitstring, bitstring): bitstring.
reduc forall x:bitstring, s:bitstring, k:bitstring ; verify(x, sign(x, k), pub(k)) = true.


(* Constants *)
const CreateSessionRequest: bitstring.
const ActivateSessionResponse: bitstring.
const None: bitstring.
const Sign: bitstring.
const SignAndEncrypt: bitstring.


(* Private keys *)
free skA: bitstring [private].
free skB: bitstring [private].
free kAB: bitstring [private].
free kAI: bitstring.
free kBI: bitstring.


(* Secrets *)
free Login: bitstring [private].
free Passwd: bitstring [private].


(* Goals *)
fun mCli(bitstring, bitstring): bitstring [private].
fun mSrv(bitstring, bitstring): bitstring [private].
query attacker(mCli(pub(skA), pub(skC))).
query attacker(mSrv(pub(skA), pub(skC))).
query attacker(Login).
query attacker(Passwd).


let client(skA: bitstring, skB: bitstring, skI: bitstring) = 
    in(c, (Cli: host, Sess: host));
    let skCli = if Cli = A then skA else if Cli = B then skB else skI in
    let pkSess = if Sess = A then pub(skA) else if Sess = B then pub(skB) else pub(skI) in
    let K = if Cli = A then if Sess = B then kAB else kAI else kBI in

    (* Role starting *)
    let m1 = CreateSessionRequest in
    out(c, (senc(m1, K), sign(m1, skCli)));

    in(c, (em2: bitstring, sigM2: bitstring));
    let m2 = sdec(em2, K) in
    if verify(m2, sigM2, pkSess) <> true then 0 else
    let (SSC: bitstring, Ns2: bitstring) = m1 in

    new CSC: bitstring;
    let m3 = (CSC, Login, Passwd) in
    out(c, (senc(m3, K), sign(m3, skCli)));

    in(c, (em4: bitstring, sigm4: bitstring));
    let m4 = sdec(em4, K) in
    if verify(m4, sigM4, pkSess) <> true then 0 else

    out(c, senc(mCli(pkCli, pkSess), Kcli)).


let disco(skA: bitstring, skB: bitstring, skC: bitstring, skI: bitstring) = 
    in(c, (Cli: host, Disco: host, Sess: host));
    let skDisco = if Disco = A then skA else if Disco = B then skB else if Disco = C then skC else skI in
    let pkDisco = pub(skDisco) in
    let pkCli = if Cli = A then pub(skA) else if Cli = B then pub(skB) else if Cli = C then pub(skC) else pub(skI) in
    let pkSess = if Sess = A then pub(skA) else if Sess = B then pub(skB) else if Sess = C then pub(skC) else pub(skI) in

    (* Role starting *)
    in(c, =GetEndpointRequest);

    new SPs: bitstring;
    new UP: bitstring;
    out(c, (SPs, SignAndEncrypt, UP, pkSess)).


let sess(skA: bitstring, skB: bitstring, skC: bitstring, skI: bitstring) = 
    in(c, (Cli: host, Disco: host, Sess: host));
    let skSess = if Sess = A then skA else if Sess = B then skB else if Sess = C then skC else skI in
    let pkSess = pub(skSess) in
    let pkCli = if Cli = A then pub(skA) else if Cli = B then pub(skB) else if Cli = C then pub(skC) else pub(skI) in
    let pkDisco = if Disco = A then pub(skA) else if Disco = B then pub(skB) else if Disco = C then pub(skC) else pub(skI) in

    (* Role starting *)
    in(c, (=pkCli, em1: bitstring, sigM1: bitstring));
    let m1 = dec(em1, skSess) in
    if verify(m1, sigM1, pkCli) <> true then 0 else
    let (SPc: bitstring, PartC: bitstring) = m1 in

    new Ns: bitstring;
    let m2 = exp(g, Ns) in
    out(c, (enc(m2, pkCli), sign(m2, skSess)));

    let Ksrv = exp(PartC, Ns) in
    out(c, senc(mSrv(pkCli, pkSess), Ksrv)).


process
    let pkA = pub(skA) in out(c, pkA);
    let pkB = pub(skB) in out(c, pkB);
    let pkC = pub(skC) in out(c, pkC);

    new skI: bitstring;
    out(c, skI);

    (!client(skA, skB, skC, skI) |
     !disco(skA, skB, skC, skI) |
     !sess(skA, skB, skC, skI)
    )
