%\newcommand{\csreq}{CreateSessionRequest}
%\newcommand{\csres}{CreateSessionResponse}
%\newcommand{\asreq}{ActivateSessionRequest}
%\newcommand{\asres}{ActivateSessionResponse}
\newcommand{\csreq}{CSReq}
\newcommand{\csres}{CSRes}
\newcommand{\asreq}{ASReq}
\newcommand{\asres}{ASRes}


The \opcua {\em CreateSession} sub-protocol allows a client to send credentials
(\emph{e.g.}: a login and a password) over an already created Secure Channel.
It  automatically follows the security mode that was chosen during the
{\em OpenSecureChannel} sub-protocol.
This sub-protocol is presented in Figure \ref{fig:session_se}.

\vspace{-1em}
\begin{figure}[htb]
    \renewcommand{\smname}{\smse}
    \resizebox{\columnwidth}{!}{
        \begin{postscript}
            \begin{msc}{Session creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{5.5\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{sess}{S}{}

                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{cli}{sess}
                \nextlevel[1.5]
                
                %\action*{Validates pk(C)}{sess}
                %\nextlevel[2.5]

                \mess{\sm{\csres, pk(S), $N_{C}$, $N_{S}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
                \nextlevel[1.5]
                
                %\action*{Validates pk(S)}{cli}
                %\nextlevel[3]
                
                \mess{\sm{\asreq, pk(C), Login, Passwd}{$K_{CS}$}{sk(C)}}{cli}{sess}
                \nextlevel[1.5]
                
                %\action*{Validates pk(C)}{sess}
                %\nextlevel[2]

                \action*{Validates (Login, Passwd) }{sess}
                \nextlevel[2.5]

                \mess{\sm{\asres, $N_{S2}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
                \nextlevel[.5]
            \end{msc}
        \end{postscript}
    }
    \caption{\opcua \session sub-protocol}
    \label{fig:session_se}
\end{figure}
\vspace{-1em}

In Figure \ref{fig:session_se}, {\em CSReq} means {\em CreateSessionRequest}
while {\em CSRes} stands for {\em CreateSessionResponse}, {\em ASReq} for
{\em ActivateSessionRequest} and {\em ASRes} for {\em ActivateSessionResponse}.
Again, these four terms indicate the purpose of each message of the protocol.

\subsection{Modeling}

As this protocol involves login and passwords, we have to make
modeling choices on how they are used.  Here we suppose that C uses a
different password for each server he speaks with.  In order to model
credentials in \proverif we use two functions: {\em Login} and {\em
  Passwd}.  {\em Login} takes as parameter the public key of a host in
order to associate his login with him. This function is public for
everybody.  {\em Passwd} takes as parameter the private key of its
owner to make it secret but also the public key of the server to model
a different password for each server.  Then we provide the following
equation: \texttt{verifyCreds(x, Login(pub(y)), Passwd(y, pub(x))) =
  true} where \texttt{x} the private key of the server and \texttt{y}
the private key of the client (not revealed to the server).  It allows
the server to verify if a password and a login are matching and if the
password is the one he knows (using his public key).  Moreover in our
modeling, we assume that the intruder can share a symmetric key with
any other participant as a result of playing the {\em
  OpenSecureChannel} sub-protocol.  However, as we said in
Section~\ref{sec:secure_channel_res}, the intruder will not obtain the
derived key if he usurps another participant.  This means that if the
intruder shares a symmetric key with another participant, then this
key is attached to a session in which he is not usurping someone's
identity.  We consider for security objectives: (i) the secrecy of the
password, (ii) the authentication of C on his password and (iii) the
authentication of S on $N_{C}$.

\subsection{Results}

Results for this protocol are presented in Table~\ref{tab:session_results}.
Again obviously, all objectives are attacked in security mode \smn.
Also the secrecy of the password cannot hold even in security mode \sms~since
it will be sent by the client in plaintext during a legitimate exchange.
However, using a different password for each server ensures the authentication
of the client.
Attack on the authentication on $N_{C}$ is similar to the attack presented in
Figure \ref{fig:secure_channel_atk}.
The intruder starts a session with the server and retoutes the packets to the
client.
However, such kind of attacks are circumvented in security mode \smse~because
as we previously said, the intruder does not possess the symmetric key of a
session where he is usurping someone's identity preventing him to communicate.

\vspace{-1em}
\begin{table}[htb]
    \centering
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{3}{|c|}{Objectives} \\
        \cline{2-4}
                       & Sec $Passwd$  & Auth $N_{C}$  & Auth $Passwd$  \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE        \\ 
        \hline
        \sms           & \UNSAFE       & \UNSAFE       & \SAFE          \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \SAFE          \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for \opcua \session sub-protocol}
    \label{tab:session_results}
\end{table}
\vspace{-4em}

\subsection{Fixed version}

We apply the same correction than in \securechan (explicitly
specifying the identities of receivers in messages).
%, the resulting protocol is displayed in Figure \ref{fig:session_fix}
Then authentication on $N_{C}$ becomes secure as shown in Table
\ref{tab:session_fix_results}.

%\begin{figure}[htb]
%    \renewcommand{\smname}{\smse}
%    \resizebox{\columnwidth}{!}{
%        \begin{postscript}
%            \begin{msc}{Session creation}
%                \setlength{\envinstdist}{1.5\envinstdist}
%                \setlength{\instdist}{6.25\instdist}
%                \setlength{\labeldist}{1.5\labeldist}
%
%                \declinst{cli}{C}{}
%                \declinst{sess}{S}{}
%
%                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{cli}{sess}
%                \nextlevel[1]
%                
%                \action*{Validates pk(C)}{sess}
%                \nextlevel[2.5]
%
%                \mess{\sm{\csres, {\bf C}, pk(S) $N_{S}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
%                \nextlevel[1]
%                
%                \action*{Validates pk(S)}{cli}
%                \nextlevel[3]
%                
%                \mess{\sm{\asreq, {\bf S}, pk(C), Login, Passwd}{$K_{CS}$}{sk(C)}}{cli}{sess}
%                \nextlevel[1]
%                
%                \action*{Validates pk(C)}{sess}
%                \nextlevel[2]
%
%                \action*{Validates (Login, Passwd) }{sess}
%                \nextlevel[2.5]
%
%                \mess{\sm{\asres, $N_{S2}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
%                \nextlevel[2]
%            \end{msc}
%        \end{postscript}
%    }
%    \caption{OPC-UA fixed CreateSession sub-protocol}
%    \label{fig:session_fix}
%\end{figure}

\vspace{-1em}
\begin{table}[htb]
    \centering
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{3}{|c|}{Objectives} \\
        \cline{2-4}
                       & Sec $Passwd$  & Auth $N_{C}$  & Auth $Passwd$  \\
        \hline                                                                          
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE        \\ 
        \hline                                         
        \sms           & \UNSAFE       & \SAFE         & \SAFE          \\ 
        \hline                                         
        \smseshort     & \SAFE         & \SAFE         & \SAFE          \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for fixed \opcua \session sub-protocol}
    \label{tab:session_fix_results}
\end{table}
\vspace{-4em}

%In a second time, we suppose that C would use different credentials for each
%server.
%Then both normal and fixed {\em CreateSession} results in Table
%\ref{tab:session_uniq_creds_results}.
%
%\begin{table}[htb]
%    \centering
%    %\resizebox{1.05\columnwidth}{!}{
%    \begin{tabular}{|c|c|c|c|}
%        \hline
%        \multirow{2}{*}{\opcua Security mode} & \multicolumn{3}{|c|}{Objectives} \\
%        \cline{2-4}
%                       & Sec $Passwd$  & Auth $N_{C}$  & Auth $Passwd$  \\
%        \hline                                                                          
%        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE       \\ 
%        \hline                                         
%        \sms           & \UNSAFE       & \UNSAFE/\SAFE & \SAFE         \\ 
%        \hline                                         
%        \smseshort     & \SAFE         & \SAFE         & \SAFE         \\ 
%        \hline
%    \end{tabular}
%    %}
%    \caption{Results for \opcua {\em CreateSession} sub-protocol with uniq credentials}
%    \label{tab:session_uniq_creds_results}
%\end{table}
%
%\TODO dire que creds uniques pour chaque serveur se comportent comme un secret partag√© permettant une auth.
%
%\begin{figure}[htb]
%    \renewcommand{\smname}{\smn}
%    \resizebox{\columnwidth}{!}{
%        \begin{postscript}
%            \begin{msc}{Session creation}
%                \setlength{\envinstdist}{1.5\envinstdist}
%                \setlength{\instdist}{3\instdist}
%                \setlength{\labeldist}{1.5\labeldist}
%
%                \declinst{cli}{C}{(C,S)}
%                \declinst{int}{I}{}
%                \declinst{sess}{S}{(C,S)}
%
%                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{cli}{int}
%                \nextlevel[1.5]
%                
%                %\action*{Validates pk(C)}{sess}
%                %\nextlevel[2.5]
%
%                \mess{\sm{\csres, pk(S), $N_{C}$, $N_{I}$}{$K_{CS}$}{sk(S)}}{int}{cli}
%                \nextlevel[1.5]
%                
%                %\action*{Validates pk(S)}{cli}
%                %\nextlevel[3]
%                
%                \msccomment{begin(C,S,Passwd(C,S))}{cli}
%                \mess{\sm{\asreq, pk(C), Login(C,S), Passwd(C,S)}{$K_{CS}$}{sk(C)}}{cli}{int}
%                \nextlevel[1.5]
%
%                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{int}{sess}
%                \nextlevel[1.5]
%
%                \mess{\sm{\csres, pk(S), $N_{C}$, $N_{S}$}{$K_{CS}$}{sk(S)}}{sess}{int}
%                \nextlevel[1.5]
%                
%                \msccomment[r]{end(C,S,Passwd(C,S))}{sess}
%                \mess{\sm{\asreq, pk(C), Login(C,S), Passwd(C,S)}{$K_{CS}$}{sk(C)}}{int}{sess}
%                \nextlevel[1.5]
%                
%                %\action*{Validates pk(C)}{sess}
%                %\nextlevel[2]
%
%                \action*{Validates (Login, Passwd) }{sess}
%                \nextlevel[2.5]
%
%                \mess{\sm{\asres, $N_{S2}$}{$K_{CS}$}{sk(S)}}{sess}{int}
%                \nextlevel[.5]
%            \end{msc}
%        \end{postscript}
%    }
%    \caption{OPC-UA CreateSession sub-protocol}
%    \label{fig:session_se}
%\end{figure}
