%\newcommand{\csreq}{CreateSessionRequest}
%\newcommand{\csres}{CreateSessionResponse}
%\newcommand{\asreq}{ActivateSessionRequest}
%\newcommand{\asres}{ActivateSessionResponse}
\newcommand{\csreq}{CSReq}
\newcommand{\csres}{CSRes}
\newcommand{\asreq}{ASReq}
\newcommand{\asres}{ASRes}

The \opcua {\em CreateSession} sub-protocol allows a client to send
credentials (\emph{e.g.}: a login and a password) over an already
created Secure Channel.  It automatically follows the security mode
that was chosen during the {\em OpenSecureChannel} sub-protocol and
uses the symmetric keys derived thus encryption becomes symmetric and
signature relies on a \emph{Message Authentication Code} (MAC).  This
way messages sent by C are encrypted using $K_{CS}$ (resp. signed with
$KSig_{CS}$) and messages sent by S are encrypted with $K_{SC}$
(resp. signed with $KSig_{SC}$).  This sub-protocol is presented in
Figure \ref{fig:session_se}.  In message 1, $C$ sends a challenge
nonce to $S$ with {\em CSReq} meaning {\em CreateSessionRequest}.  In
message 2, $S$ answers with $Sig_{N_{C}} = \left\{\mbox{pk(C),
  $N_{C}$}\right\}_{\mbox{sk(S)}}$ and {\em CSRes} for {\em
  CreateSessionResponse}.  $Sig_{N_{C}}$ is the response of C's
challenge and requires S to sign with its private (asymmetric) key to
prove that he is the sams as in the {\em OpenSecureChannel}
sub-protocol.  For this particular use, the \opcua standard explicitly
asks to add C's public key to the signature (which confirms the
counter-measure we give in Section~\ref{sec:secure_channel_fix}).  In
message 3, $C$ answers S's challenge with $Sig_{N_{S}}$ and sends his
credentials to $S$ with {\em ASReq} for {\em ActivateSessionRequest}.
Finally in message 4, $S$ confirms to $C$ that the session is created
with {\em ASRes} for {\em ActivateSessionResponse} and $N_{S2}$ a
fresh challenge nonce that C should use to refresh the session when it
is timed-out.  Again, {\em CSReq, CSRes, ASReq} and {\em ASRes}
indicate the purpose of each message of the protocol.

\begin{figure}[htb]
    \resizebox{\textwidth}{!}{
        \begin{postscript}
            \begin{msc}{Session creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{6.25\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{sess}{S}{}

                \mess{\dosmhmacencrypt{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{$KSig_{CS}$}}{cli}{sess}
                \nextlevel[1.5]
                
                \mess{\dosmhmacencrypt{\csres, pk(S), $Sig_{N_{C}}$, $N_{S}$}{$K_{SC}$}{$KSig_{SC}$}}{sess}{cli}
                \nextlevel[1]

                \action*{Validates $Sig_{N_{C}}$}{cli}
                \nextlevel[3]
                
                \mess{\dosmhmacencrypt{\asreq, $Sig_{N_{S}}$, pk(C), Login, Passwd}{$K_{CS}$}{$KSig_{CS}$}}{cli}{sess}
                \nextlevel[1]

                \action*{Validates $Sig_{N_{S}}$}{sess}
                \nextlevel[2]

                \action*{Validates (Login, Passwd)}{sess}
                \nextlevel[2.5]

                \mess{\dosmhmacencrypt{\asres, $N_{S2}$}{$K_{SC}$}{$KSig_{SC}$}}{sess}{cli}
                \nextlevel[.5]
            \end{msc}
        \end{postscript}
    }
    \caption{\opcua \session sub-protocol}
    \label{fig:session_se}
\end{figure}

\subsection{Modeling}

As this protocol involves login and passwords, we have to make
modeling choices on how they are used.  Here we suppose that C uses a
different password for each server he speaks with.  In order to model
credentials in \proverif we use two functions: {\em Login} and {\em
  Passwd}.  {\em Login} takes as parameter the public key of a host in
order to associate his login with him. This function is public for
everybody.  {\em Passwd} takes as parameter the private key of its
owner to make it secret but also the public key of the server to model
a different password for each server.  Then we provide the following
equation: \texttt{verifyCreds(x, Login(pub(y)), Passwd(y, pub(x))) =
  true} where \texttt{x} the private key of the server and \texttt{y}
the private key of the client (not revealed to the server).  It allows
the server to verify if a password and a login are matching and if the
password is the one he knows (using his public key).
%Moreover in our
%modeling, we assume that the intruder can share a symmetric key with
%any other participant as a result of playing the {\em
%  OpenSecureChannel} sub-protocol.  However, as we said in
%Section~\ref{sec:secure_channel_res}, the intruder will not obtain the
%derived key if he usurps another participant.  This means that if the
%intruder shares a symmetric key with another participant, then this
%key is attached to a session in which he is not usurping someone's
%identity.
According to our results for the {\em OpenSecureChannel} sub-protocol, the
secrecy of the symmetric keys in security mode \sms~depends on if the protocol
uses key wrapping.
Again, as the \opcua standard is not clear on how to use the mechanism in
this mode, we check with and without this security.
This means that is keys are compromised, then the intruder has access to it.
We consider four security objectives: (i) the secrecy of the
password, (ii) the authentication of C on his password, (iii) the
authentication of C on $Sig_{N_{S}}$ and (iv) the authentication of S on
$Sig_{N_{C}}$.

\subsection{Results}

Results without key wrapping (thus with keys leaked in security mode \sms) are
presented in Table~\ref{tab:session_results}.
Again obviously, all objectives are attacked in security mode \smn.
Also the secrecy of the password cannot hold even in security mode \sms~since
it will be sent by the client in plaintext during a legitimate exchange.
However, both challenge-response nonces ensure authentication since the private
keys are used instead of the symmetric keys.
An attack on the authentication on $Passwd$ in security mode \sms~is found by
the tool.
This attacks results in the intruder replacing the credentials of C by other
valid credentials and recalculating the MAC of the message using the leaked keys.
%Such an attack means first, that the intruder can overtake the session of C
%after having him answering S's challenge.
%Moreover in our model, the intruder could also usurp someone else than C in this
%session.

\vspace{-1em}
\begin{table}[htb]
    \centering
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{4}{|c|}{Objectives} \\
        \cline{2-5}
                    & Sec $Passwd$  & Auth $Passwd$  & Auth $Sig_{N_{S}}$    & Auth $Sig_{N_{C}}$    \\
        \hline                                       
        \smn        & \UNSAFE       & \UNSAFE        & \UNSAFE               & \UNSAFE               \\ 
        \hline                                       
        \sms        & \UNSAFE       & \UNSAFE        & \SAFE                 & \SAFE                 \\ 
        \hline                                       
        \smseshort  & \SAFE         & \SAFE          & \SAFE                 & \SAFE                 \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for \opcua \session sub-protocol}
    \label{tab:session_results}
\end{table}
\vspace{-2em}

If we consider that key wrapping was used in the {\em OpenSecureChannel}
sub-protocol (thus without keys leaked in security mode Sign) then the
authentication on C's password becomes secure.
This analysis shows that the use of key wrapping is crucial in security mode
\sms.
Thus it should be clearly said in the \opcua standard since missing this feature
completely breaks the security of \sms~mode.
Moreover, C's credential should also be encrypted when exchanged in \sms~mode
to ensure their confidentiality.
We were able to check the source code of the free implementation of \opcua:
{\em FreeOpcUa} which forces encryption of secrets even in security mode \sms.
