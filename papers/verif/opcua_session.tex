%\newcommand{\csreq}{CreateSessionRequest}
%\newcommand{\csres}{CreateSessionResponse}
%\newcommand{\asreq}{ActivateSessionRequest}
%\newcommand{\asres}{ActivateSessionResponse}
\newcommand{\csreq}{CSReq}
\newcommand{\csres}{CSRes}
\newcommand{\asreq}{ASReq}
\newcommand{\asres}{ASRes}


The \opcua {\em CreateSession} sub-protocol allows a client to send credentials
(\emph{e.g.}: a login and a password) over an already created Secure Channel.
It  automatically follows the security mode that was chosen during the
{\em OpenSecureChannel} sub-protocol.
This sub-protocol is presented in Figure \ref{fig:session_se}.

\begin{figure}[htb]
    \renewcommand{\smname}{\smse}
    \resizebox{\columnwidth}{!}{
        \begin{postscript}
            \begin{msc}{Session creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{5.5\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{sess}{S}{}

                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{cli}{sess}
                \nextlevel[1.5]
                
                %\action*{Validates pk(C)}{sess}
                %\nextlevel[2.5]

                \mess{\sm{\csres, pk(S), $N_{C}$, $N_{S}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
                \nextlevel[1.5]
                
                %\action*{Validates pk(S)}{cli}
                %\nextlevel[3]
                
                \mess{\sm{\asreq, pk(C), Login, Passwd}{$K_{CS}$}{sk(C)}}{cli}{sess}
                \nextlevel[1.5]
                
                %\action*{Validates pk(C)}{sess}
                %\nextlevel[2]

                \action*{Validates (Login, Passwd) }{sess}
                \nextlevel[2.5]

                \mess{\sm{\asres, $N_{S2}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
                \nextlevel[.5]
            \end{msc}
        \end{postscript}
    }
    \caption{OPC-UA CreateSession sub-protocol}
    \label{fig:session_se}
\end{figure}

\subsection{Modeling}

%For this protocol, a modeling choice appears.
%We can either suppose that C respects security standards and would use different
%credentials for each server or suppose he will always send the same login and
%password for all servers.
As this protocol involves login and passwords, we have to make modeling choices
on how they are used.
Here we suppose that C uses a different password for each server he speaks with.
%the same credentials including in a session
%with the intruder (possibly a rogue server controled by the intruder).
\TODO Explain modelization.

Moreover in our modeling, we assume that the intruder can share a symmetric key
with any other participant as a result of playing the {\em OpenSecureChannel}
sub-protocol.
However, as we said in Section \ref{sec:secure_channel_res}, he will not obtain
the derived key if he usurps another participant.
This means that if the intruder shares a symmetric key with another participant,
then this key is attached to a session in which he is not usurping someone's
identity.
We consider for security objectives: (i) the secrecy of the credentials, (ii)
the authentication of C on his credentials and (iii) the authentication of S on
$g^{N_{S}}$.

\subsection{Results}

Results under this assumption are presented in Table \ref{tab:session_results}.
Again obviously, all objectives are attacked in security mode \smn.
Also the secrecy of the password can not hold even in security mode \sms~since
it will be revealed by the client to the server during a legitimate exchange.
However, using a different password for each server ensures the authentication
of the client with other security modes.
Attack on the athentication on $N_{S}$ is similar to the attack presented in
Figure \ref{fig:secure_channel_atk}.
The intruder starts a session with the server and retoutes the packets to the
client.
However, such kind of attacks are circumvented in security mode \smse~because
as we previously said, the intruder does not possess the symmetric key of a
session where he is usurping someone's identity preventing him to communicate.
Attacks on the secrecy of the credentials occur because the client will accept
the intruder's public key (and signatures) according to our intruder model.
Thus as the client always uses the same credentials, then he will reveal them to
the intruder just by playing the sub-protocol.

\begin{table}[htb]
    \centering
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{3}{|c|}{Objectives} \\
        \cline{2-4}
                       & Sec $Creds$   & Auth $N_S$    & Auth $Creds$   \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE        \\ 
        \hline
        \sms           & \UNSAFE       & \UNSAFE       & \SAFE          \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \SAFE          \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for \opcua {\em CreateSession} sub-protocol}
    \label{tab:session_results}
\end{table}

\subsection{Fixed version}

We apply the same correction than in {\em OpenSecureChannel} (explicitly
specifying the identities of recievers in messages).
%, the resulting protocol is displayed in Figure \ref{fig:session_fix}
Then authentication on $N_{S}$ becomes secure as shown in Table
\ref{tab:session_fix_results}.

%\begin{figure}[htb]
%    \renewcommand{\smname}{\smse}
%    \resizebox{\columnwidth}{!}{
%        \begin{postscript}
%            \begin{msc}{Session creation}
%                \setlength{\envinstdist}{1.5\envinstdist}
%                \setlength{\instdist}{6.25\instdist}
%                \setlength{\labeldist}{1.5\labeldist}
%
%                \declinst{cli}{C}{}
%                \declinst{sess}{S}{}
%
%                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{cli}{sess}
%                \nextlevel[1]
%                
%                \action*{Validates pk(C)}{sess}
%                \nextlevel[2.5]
%
%                \mess{\sm{\csres, {\bf C}, pk(S) $N_{S}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
%                \nextlevel[1]
%                
%                \action*{Validates pk(S)}{cli}
%                \nextlevel[3]
%                
%                \mess{\sm{\asreq, {\bf S}, pk(C), Login, Passwd}{$K_{CS}$}{sk(C)}}{cli}{sess}
%                \nextlevel[1]
%                
%                \action*{Validates pk(C)}{sess}
%                \nextlevel[2]
%
%                \action*{Validates (Login, Passwd) }{sess}
%                \nextlevel[2.5]
%
%                \mess{\sm{\asres, $N_{S2}$}{$K_{CS}$}{sk(S)}}{sess}{cli}
%                \nextlevel[2]
%            \end{msc}
%        \end{postscript}
%    }
%    \caption{OPC-UA fixed CreateSession sub-protocol}
%    \label{fig:session_fix}
%\end{figure}

\begin{table}[htb]
    \centering
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{3}{|c|}{Objectives} \\
        \cline{2-4}
                       & Sec $Creds$   & Auth $N_S$    & Auth $Creds$   \\
        \hline                                                                          
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE        \\ 
        \hline                                         
        \sms           & \UNSAFE       & \SAFE         & \SAFE          \\ 
        \hline                                         
        \smseshort     & \SAFE         & \SAFE         & \SAFE          \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for fixed \opcua {\em CreateSession} sub-protocol}
    \label{tab:session_fix_results}
\end{table}

%In a second time, we suppose that C would use different credentials for each
%server.
%Then both normal and fixed {\em CreateSession} results in Table
%\ref{tab:session_uniq_creds_results}.
%
%\begin{table}[htb]
%    \centering
%    %\resizebox{1.05\columnwidth}{!}{
%    \begin{tabular}{|c|c|c|c|}
%        \hline
%        \multirow{2}{*}{\opcua Security mode} & \multicolumn{3}{|c|}{Objectives} \\
%        \cline{2-4}
%                       & Sec $Creds$   & Auth $N_S$    & Auth $Creds$   \\
%        \hline                                                                          
%        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE       \\ 
%        \hline                                         
%        \sms           & \UNSAFE       & \UNSAFE/\SAFE & \SAFE         \\ 
%        \hline                                         
%        \smseshort     & \SAFE         & \SAFE         & \SAFE         \\ 
%        \hline
%    \end{tabular}
%    %}
%    \caption{Results for \opcua {\em CreateSession} sub-protocol with uniq credentials}
%    \label{tab:session_uniq_creds_results}
%\end{table}
%
%\TODO dire que creds uniques pour chaque serveur se comportent comme un secret partag√© permettant une auth.
%
%\begin{figure}[htb]
%    \renewcommand{\smname}{\smn}
%    \resizebox{\columnwidth}{!}{
%        \begin{postscript}
%            \begin{msc}{Session creation}
%                \setlength{\envinstdist}{1.5\envinstdist}
%                \setlength{\instdist}{3\instdist}
%                \setlength{\labeldist}{1.5\labeldist}
%
%                \declinst{cli}{C}{(C,S)}
%                \declinst{int}{I}{}
%                \declinst{sess}{S}{(C,S)}
%
%                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{cli}{int}
%                \nextlevel[1.5]
%                
%                %\action*{Validates pk(C)}{sess}
%                %\nextlevel[2.5]
%
%                \mess{\sm{\csres, pk(S), $N_{C}$, $N_{I}$}{$K_{CS}$}{sk(S)}}{int}{cli}
%                \nextlevel[1.5]
%                
%                %\action*{Validates pk(S)}{cli}
%                %\nextlevel[3]
%                
%                \msccomment{begin(C,S,Passwd(C,S))}{cli}
%                \mess{\sm{\asreq, pk(C), Login(C,S), Passwd(C,S)}{$K_{CS}$}{sk(C)}}{cli}{int}
%                \nextlevel[1.5]
%
%                \mess{\sm{\csreq, pk(C), $N_{C}$}{$K_{CS}$}{sk(C)}}{int}{sess}
%                \nextlevel[1.5]
%
%                \mess{\sm{\csres, pk(S), $N_{C}$, $N_{S}$}{$K_{CS}$}{sk(S)}}{sess}{int}
%                \nextlevel[1.5]
%                
%                \msccomment[r]{end(C,S,Passwd(C,S))}{sess}
%                \mess{\sm{\asreq, pk(C), Login(C,S), Passwd(C,S)}{$K_{CS}$}{sk(C)}}{int}{sess}
%                \nextlevel[1.5]
%                
%                %\action*{Validates pk(C)}{sess}
%                %\nextlevel[2]
%
%                \action*{Validates (Login, Passwd) }{sess}
%                \nextlevel[2.5]
%
%                \mess{\sm{\asres, $N_{S2}$}{$K_{CS}$}{sk(S)}}{sess}{int}
%                \nextlevel[.5]
%            \end{msc}
%        \end{postscript}
%    }
%    \caption{OPC-UA CreateSession sub-protocol}
%    \label{fig:session_se}
%\end{figure}
