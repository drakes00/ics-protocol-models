%\newcommand{\gereq}{GetEndpointRequest}
%\newcommand{\geres}{GetEndpointResponse}
%\newcommand{\oscreq}{OpenSecureChannelRequest}
%\newcommand{\oscres}{OpenSecureChannelResponse}
\newcommand{\gereq}{GEReq}
\newcommand{\geres}{GERes}
\newcommand{\oscreq}{OSCReq}
\newcommand{\oscres}{OSCRes}


The {\em OpenSecureChannel} sub-protocol described in
Figure~\ref{fig:secure_channel_se} aims to authenticate a client and
a server and allows them to generate a shared key for the later communications.
\opcua can be used with three security modes, namely {\em \smn}, {\em \sms} and
{\em \smse}.

\begin{itemize}
    \item \smse: claims to provide secrecy using symetric and
      assymetric encryption and both authentication and integrity
      through digital signatures.
    \item \sms: same as {\em \smse} but without any encryption.  Thus
      nonces are not used to generate a shared key but bring freshness
      to the messages.
    \item \smn: does not provide any security.  Using this mode, the
      {\em OpenSecureChannel} sub-protocol does not serve much
      purpose but is used for compatibility.
\end{itemize}

\begin{figure}[htb]
    \centering
    \renewcommand{\smname}{\smseshort}
    \resizebox{.8\linewidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{2.6\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{DiscoreryEndpoint}{}
                \declinst{sess}{S}{}

                \msccomment[-.5]{1.}{cli}
                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \msccomment[-.5]{2.}{cli}
                \mess{\geres, pk(S), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                %\action*{Validates pk(S)}{cli}
                %\nextlevel[2]
                
                \action*{Generates N$_{C}$}{cli}
                \nextlevel[3]

                \msccomment[-.5]{3.}{cli}
                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{cli}{sess}
                \nextlevel[1]

                %\action*{Validates pk(C) }{sess}
                %\nextlevel[2]

                \action*{Generates N$_{S}$ }{sess}
                \nextlevel[2]

                \ifsmnotnone{%
                    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
                    \nextlevel[3.5]
                }

                \msccomment[-.5]{4.}{cli}
                \mess{\sm{\oscres, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{cli}
                \nextlevel[1]

                \ifsmnotnone{%
                    \action*{$K_{cli}$ = $(g^{N_{S}})^{N_{C}}$}{cli}
                    \nextlevel[2]
                }
            \end{msc}
        \end{postscript}
    }
    \caption{\opcua OpenSecureChannel sub-protocol}
    \label{fig:secure_channel_se}
\end{figure}

\subsection{Modeling}

Normaly, a {\em GetEnpointRequest} would be answered by a list of
session endpoints with possibly different security modes. We suppose
that only one endpoint is answered and that the client will always
accept the security mode proposed.  Moreover, thanks to the perfect
encryption hypothesis, we can abstract the cryptographic suite
negociation.  We consider an intruder whose public key would be
accepted by a legitimate client or server.  Such an intruder could for
instance represent a legitimate device that has been corrupted through
a virus or that is controlled by a malicious operator.  Finally, it is
said in \cite{MLD09} that ``\emph{The establishement of the Secure
  Channel is mainly used for exchanging special secret information
  between clients and servers. This secret is used for deriving
  Symetric Keys $[...]$}''.  To the best of our knowledge, no more
precision is given in \cite{MLD09,opcua_part2,opcua_part4,opcua_part6}
on which cryptographic primitives should be used for such purpose.
Thus we chose to model this key derivation using the \DiH mecanisms
which relies on the commutativity of the exponentiation: $(g^a)^b =
(g^b)^a$.  In this context, we consider the following four security
objectives:
\begin{enumerate}
    \item\label{item:sc_sec_cli} Secrecy of $K_{cli}$ obtained by C.
    \item\label{item:sc_sec_srv} Secrecy of $K_{src}$ obtained by S.
    \item\label{item:sc_auth_cli} Authentication of C on $g^{Nc}$.
    \item\label{item:sc_auth_srv} Authentication of S on $g^{Ns}$.
\end{enumerate}

\subsection{Results}\label{sec:secure_channel_res}

We run \proverif on this protocol for each combination of the three security
modes of \opcua for each objective proposed.
Results are shown in Table \ref{tab:secure_channel_results}.

\begin{table}[htb]
    \centering
    %\hspace{-1em}
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{4}{|c|}{Objectives} \\
        \cline{2-5}
                       & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $g^{N_{S}}$  & Auth $g^{N_{C}}$  \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \sms           & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for textbook {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_channel_results}
\end{table}

Obviously, as the security mode \smn~does not provide any security,
all objectives can be attacked.  Moreover, attacks on authentication
in the case of \sms~and \smse~implies the intruder rerouting messages.
Such manipulation differs from replaying a message as it does not
delay the message more than what a legitimaete router would do (thus
avoiding replay protections such as timestamps).  Figure
\ref{fig:secure_channel_atk} shows an attack on the authentication of
C using $g^{N_{C}}$.  This attack is possible because the standard
\opcua protocol does not require explicitly to specify the identity of
the receiver of a message.  Thus it allows the intruder to send to S
the signed message C sent to him similarily as the attack on the
Needham-Schroeder protocol~\cite{Low96}.  However, these attacks are
not exploitable in security mode \smse~since the secrecy of the keys
is proven by the tool.  It means that even if an intruder can usurp a
client when speaking to a server and vice-versa, he will not obtain
the key derived by the protocol.

\begin{figure}[htb]
    \hspace{-2.25em}
    \renewcommand{\smname}{\smse}
    \resizebox{1.1\columnwidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{5.1\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{I}{}
                \declinst{sess}{S}{}

                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \mess{\geres, pk(I), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                %\action*{Validates pk(I)}{cli}
                %\nextlevel[2]
                
                \action*{Generates N$_{C}$}{cli}
                \nextlevel[3]

                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(I)}{sk(C)}}{cli}{intruder}
                \nextlevel[2]

                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{intruder}{sess}
                \nextlevel[1]

                %\action*{Validates pk(C) }{sess}
                %\nextlevel[2]

                %\action*{Generates N$_{S}$ }{sess}
                %\nextlevel[2]

                %\ifsmnotnone{%
                %    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
                %    \nextlevel[3]
                %}

                %\mess{\sm{\oscres, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{intruder}
                %\nextlevel[1.5]
            \end{msc}
        \end{postscript}
    }
    \caption{Attack on $g^{N_{C}}$: I usurps C when speaking to S}
    \label{fig:secure_channel_atk}
\end{figure}

\subsection{Fixed version}

We propose a fixed version of the {\em OpenSecureChannel} sub-protocol.
%in Figure \ref{fig:secure_channel_fix_se}.
It consists in adding the identity of the reciever to the messages and thus 
avoids an intruder rerouting signed messages to usurp hosts as presented
in Section \ref{sec:secure_channel_res}.
More formaly, message 3. and 4. of Figure~\ref{fig:secure_channel_se} are replaced
by:

\arraycolsep=1.4pt
\begin{flushleft}
    \[\begin{array}{lrllll}
        3. & C & \rightarrow & S & : & \text{\small\sm{\oscreq, {\bf S}, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}\\
        4. & S & \rightarrow & C & : & \text{\small\sm{\oscres, {\bf C}, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}\\
    \end{array}\]
\end{flushleft}

%\begin{figure}[htb]
%    \hspace{-1em}
%    \renewcommand{\smname}{\smseshort}
%    \resizebox{1.05\columnwidth}{!}{
%        \begin{postscript}
%            \begin{msc}{Secure channel creation}
%                \setlength{\envinstdist}{1.5\envinstdist}
%                \setlength{\instdist}{2.8\instdist}
%                \setlength{\labeldist}{1.5\labeldist}
%
%                \declinst{cli}{C}{}
%                \declinst{intruder}{DiscoreryEndpoint}{}
%                \declinst{sess}{S}{}
%
%                \mess{\gereq}{cli}{intruder}
%                \nextlevel[1.5]
%
%                \mess{\geres, pk(S), \smname, SP, UP}{intruder}{cli}
%                \nextlevel[1]
%                
%                \action*{Validates pk(S)}{cli}
%                \nextlevel[2]
%                
%                \action*{Generates N$_{C}$}{cli}
%                \nextlevel[3]
%
%                \mess{pk(C), \sm{\oscreq, {\bf S}, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{cli}{sess}
%                \nextlevel[1]
%
%                \action*{Validates pk(C) }{sess}
%                \nextlevel[2]
%
%                \action*{Generates N$_{S}$ }{sess}
%                \nextlevel[2]
%
%                \ifsmnotnone{%
%                    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
%                    \nextlevel[3.5]
%                }
%
%                \mess{\sm{\oscres, {\bf C}, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{cli}
%                \nextlevel[1]
%
%                \ifsmnotnone{%
%                    \action*{$K_{cli}$ = $(g^{N_{S}})^{N_{C}}$}{cli}
%                    \nextlevel[2]
%                }
%            \end{msc}
%        \end{postscript}
%    }
%    \caption{\opcua OpenSecureChannel sub-protocol}
%    \label{fig:secure_channel_fix_se}
%\end{figure}

We also use \proverif to prove the security of this fixed version. The
results are presented in Table \ref{tab:secure_channel_fix_results} and
show that now there is no attack found on authentication.

\begin{table}[htb]
    \centering
    %\hspace{-1em}
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{4}{|c|}{Objectives} \\
        \cline{2-5}
                       & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $g^{N_{S}}$  & Auth $g^{N_{C}}$  \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \sms           & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for fixed {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_channel_fix_results}
\end{table}
