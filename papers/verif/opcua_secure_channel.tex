%\newcommand{\gereq}{GetEndpointRequest}
%\newcommand{\geres}{GetEndpointResponse}
%\newcommand{\oscreq}{OpenSecureChannelRequest}
%\newcommand{\oscres}{OpenSecureChannelResponse}
\newcommand{\gereq}{GEReq}
\newcommand{\geres}{GERes}
\newcommand{\oscreq}{OSCReq}
\newcommand{\oscres}{OSCRes}


The {\em OpenSecureChannel} sub-protocol described in
Figure~\ref{fig:secure_channel_se} aims to authenticate a client and
a server and allows them to generate a shared key for the later communications.
\opcua can be used with three security modes, namely {\em \smn}, {\em \sms} and
{\em \smse}.
\vspace{-.5em}
\begin{itemize}
    \item {\em \smse}: claims to provide secrecy using symmetric and
      asymmetric encryption and both authentication and integrity
      through digital signatures (\eg $enc_{pkB}(m)$, $sig_{skA}(h(m))$).
  \item {\em \sms}: same as {\em \smse} but without any encryption.  Thus
      nonces are not used to generate a shared key but bring freshness
      to the messages (\eg m, $sig_{skA}(h(m))$).
  \item {\em \smn}: does not provide any security.  Using this mode, the
      {\em OpenSecureChannel} sub-protocol does not serve much
      purpose but is used for compatibility.
\end{itemize}

\vspace{-1em}
\begin{figure}[htb]
    \centering
    \renewcommand{\smname}{\smseshort}
    \resizebox{.8\linewidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{2.6\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{DiscoreryEndpoint}{}
                \declinst{sess}{S}{}

                \msccomment[-.5]{1.}{cli}
                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \msccomment[-.5]{2.}{cli}
                \mess{\geres, pk(S), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                %\action*{Validates pk(S)}{cli}
                %\nextlevel[2]
                
                \action*{Generates N$_{C}$}{cli}
                \nextlevel[3]

                \msccomment[-.5]{3.}{cli}
                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{cli}{sess}
                \nextlevel[1]

                %\action*{Validates pk(C) }{sess}
                %\nextlevel[2]

                \action*{Generates N$_{S}$ }{sess}
                \nextlevel[2]

                \ifsmnotnone{%
                    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
                    \nextlevel[3.5]
                }

                \msccomment[-.5]{4.}{cli}
                \mess{\sm{\oscres, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{cli}
                \nextlevel[1]

                \ifsmnotnone{%
                    \action*{$K_{cli}$ = $(g^{N_{S}})^{N_{C}}$}{cli}
                    \nextlevel[2]
                }
            \end{msc}
        \end{postscript}
    }
    \caption{\opcua \securechan sub-protocol}
    \label{fig:secure_channel_se}
\end{figure}
\vspace{-1em}

In Figure \ref{fig:secure_channel_se}, {\em GEReq} means
{\em GetEndpointRequest} while {\em GERes} stands for {\em GetEndpointResponse},
{\em OSReq} for {\em OpenSecureChannelRequest} and {\em OSCRes} for
{\em OpenSecureChannelResponse}.
These four terms indicate the purpose of each message of the protocol.
Then, {\em SP} and {\em UP} respectively stand for {\em Security Policy} and
{\em UserPolicy}.
Both are used for cryptographic primitive negociations.
Finally, {\em ST} and {\em TTL} mean {\em SecurityToken} and {\em TimeToLive}.
The first is a unique identifier for the channel and the second represents its
life-time.

\subsection{Modeling}

Normally, a {\em GetEnpointRequest} would be answered by a list of
session endpoints with possibly different security modes. We suppose
that only one endpoint is answered and that the client will always
accept the security mode proposed.  Moreover, thanks to the perfect
encryption hypothesis, we can abstract the cryptographic primitives
used.  We consider an intruder whose public key would be accepted by a
legitimate client or server.  Such an intruder could for instance
represent a legitimate device that has been corrupted through a virus
or that is controlled by a malicious operator.  Finally, it is said in
\cite{MLD09} that ``\emph{The establishment of the Secure Channel is
  mainly used for exchanging special secret information between
  clients and servers. This secret is used for deriving Symmetric Keys
  $[...]$}''.  To the best of our knowledge, no more precision is
given in \cite{MLD09,opcua_part2,opcua_part4,opcua_part6} on which
cryptographic primitives should be used for such purpose.  Thus we
chose to model this key derivation using the \DiH mechanisms which
relies on the commutativity of the exponentiation: $(g^a)^b =
(g^b)^a$.  In this context, we consider the following four security
objectives:
\vspace{-.5em}
\begin{itemize}
    \item\label{item:sc_sec_cli} Secrecy of $K_{cli}$ obtained by C.
    \item\label{item:sc_sec_srv} Secrecy of $K_{src}$ obtained by S.
    \item\label{item:sc_auth_cli} Authentication of C on $g^{Nc}$.
    \item\label{item:sc_auth_srv} Authentication of S on $g^{Ns}$.
\end{itemize}

\subsection{Results}\label{sec:secure_channel_res}

We run \proverif on this protocol for of the three security
modes of \opcua for each objective proposed.
Results are shown in Table \ref{tab:secure_channel_results}.

\vspace{-1em}
\begin{table}[htb]
    \centering
    %\hspace{-1em}
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{4}{|c|}{Objectives} \\
        \cline{2-5}
                       & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $g^{N_{S}}$  & Auth $g^{N_{C}}$  \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \sms           & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for textbook {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_channel_results}
\end{table}
\vspace{-2em}

Obviously, as the security mode \smn~does not provide any security,
all objectives can be attacked.  Moreover, attacks on authentication
in the case of \sms~and \smse~implies the intruder rerouting messages.
Such manipulation differs from replaying a message as it does not
delay the message more than what a legitimate router would do (thus
avoiding replay protections such as timestamps).  Figure
\ref{fig:secure_channel_atk} shows an attack on the authentication of
C using $g^{N_{C}}$.  This attack is possible because the standard
\opcua protocol does not require explicitly to specify the identity of
the receiver of a message.  Thus it allows the intruder to send to S
the signed message C sent to him similarly as the attack on the
Needham-Schroeder protocol~\cite{Low96}.  However, these attacks are
not exploitable in security modes \sms~and \smse~since the secrecy of the keys
is proven by the tool.  It means that even if an intruder can usurp a
client when speaking to a server and vice-versa, he will not obtain
the key derived by the protocol.
Such property holds thanks to the \DiH key derivation mechanism that allows
to exchange the nonces without revealing them (sending $g^{N_{C}}$ instead of 
$N_{C}$).

\vspace{-1em}
\begin{figure}[htb]
    \hspace{-2.25em}
    \renewcommand{\smname}{\smse}
    \resizebox{1.1\columnwidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{5.1\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{I}{}
                \declinst{sess}{S}{}

                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \mess{\geres, pk(I), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                %\action*{Validates pk(I)}{cli}
                %\nextlevel[2]
                
                \action*{Generates N$_{C}$}{cli}
                \nextlevel[3]

                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(I)}{sk(C)}}{cli}{intruder}
                \nextlevel[2]

                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{intruder}{sess}
                \nextlevel[1]

                %\action*{Validates pk(C) }{sess}
                %\nextlevel[2]

                %\action*{Generates N$_{S}$ }{sess}
                %\nextlevel[2]

                %\ifsmnotnone{%
                %    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
                %    \nextlevel[3]
                %}

                %\mess{\sm{\oscres, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{intruder}
                %\nextlevel[1.5]
            \end{msc}
        \end{postscript}
    }
    \caption{Attack on $g^{N_{C}}$: I usurps C when speaking to S}
    \label{fig:secure_channel_atk}
\end{figure}
\vspace{-2.5em}

\subsection{Fixed version}

We propose a fixed version of the {\em OpenSecureChannel} sub-protocol.
%in Figure \ref{fig:secure_channel_fix_se}.
It consists in adding the identity of the receiver to the messages and thus 
avoids an intruder rerouting signed messages to usurp hosts as presented
in Section \ref{sec:secure_channel_res}.
More formally, message 3. and 4. of Figure~\ref{fig:secure_channel_se} are replaced
by:

\arraycolsep=1.4pt
\begin{flushleft}
    \[\begin{array}{lrllll}
        3. & C & \rightarrow & S & : & \text{\small\sm{\oscreq, {\bf S}, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}\\
        4. & S & \rightarrow & C & : & \text{\small\sm{\oscres, {\bf C}, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}\\
    \end{array}\]
\end{flushleft}

%\begin{figure}[htb]
%    \hspace{-1em}
%    \renewcommand{\smname}{\smseshort}
%    \resizebox{1.05\columnwidth}{!}{
%        \begin{postscript}
%            \begin{msc}{Secure channel creation}
%                \setlength{\envinstdist}{1.5\envinstdist}
%                \setlength{\instdist}{2.8\instdist}
%                \setlength{\labeldist}{1.5\labeldist}
%
%                \declinst{cli}{C}{}
%                \declinst{intruder}{DiscoreryEndpoint}{}
%                \declinst{sess}{S}{}
%
%                \mess{\gereq}{cli}{intruder}
%                \nextlevel[1.5]
%
%                \mess{\geres, pk(S), \smname, SP, UP}{intruder}{cli}
%                \nextlevel[1]
%                
%                \action*{Validates pk(S)}{cli}
%                \nextlevel[2]
%                
%                \action*{Generates N$_{C}$}{cli}
%                \nextlevel[3]
%
%                \mess{pk(C), \sm{\oscreq, {\bf S}, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{cli}{sess}
%                \nextlevel[1]
%
%                \action*{Validates pk(C) }{sess}
%                \nextlevel[2]
%
%                \action*{Generates N$_{S}$ }{sess}
%                \nextlevel[2]
%
%                \ifsmnotnone{%
%                    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
%                    \nextlevel[3.5]
%                }
%
%                \mess{\sm{\oscres, {\bf C}, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{cli}
%                \nextlevel[1]
%
%                \ifsmnotnone{%
%                    \action*{$K_{cli}$ = $(g^{N_{S}})^{N_{C}}$}{cli}
%                    \nextlevel[2]
%                }
%            \end{msc}
%        \end{postscript}
%    }
%    \caption{\opcua OpenSecureChannel sub-protocol}
%    \label{fig:secure_channel_fix_se}
%\end{figure}

Note that instead of adding identity in these messages, one could add the user's
public keys (pk(C) instead of C for instance).
This is one of the classical counter-measures for communication protocols
proposed in \cite{AN96}.
We also use \proverif to check the security of this fixed version. The
results are presented in Table \ref{tab:secure_channel_fix_results} and
show that now there is no attack found on authentication.

\begin{table}[htb]
    \centering
    %\hspace{-1em}
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua Security mode} & \multicolumn{4}{|c|}{Objectives} \\
        \cline{2-5}
                       & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $g^{N_{S}}$  & Auth $g^{N_{C}}$  \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \sms           & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for fixed {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_channel_fix_results}
\end{table}
