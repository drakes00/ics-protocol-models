%\newcommand{\gereq}{GetEndpointRequest}
%\newcommand{\geres}{GetEndpointResponse}
%\newcommand{\oscreq}{OpenSecureChannelRequest}
%\newcommand{\oscres}{OpenSecureChannelResponse}
\newcommand{\gereq}{GEReq}
\newcommand{\geres}{GERes}
\newcommand{\oscreq}{OSCReq}
\newcommand{\oscres}{OSCRes}


The {\em OpenSecureChannel} sub-protocol  aims to authenticate a client and
a server and allows them to generate a shared key for the later communications.
\opcua{} can be used with three security modes, namely {\em \smn}, {\em \sms} and
{\em \smse}.
\vspace{-.5em}
\begin{itemize}
    \item {\em \smse}: messages are signed $\{h(m)\}_{sk(X)}$ and
      encrypted $\{m\}_{pk(X)}$, where $h$ is an hash function, $sk(X)$ the secret key associated to $X$ and $pk(X)$ the public key of $X$.
      This mode claims to provide secrecy
      using symmetric and asymmetric encryption, but also both
      authentication and integrity through digital signatures.
  \item {\em \sms}: messages are only signed $m$, $\{h(m)\}_{sk(x)}$,
    it is the same as {\em \smse} but without any encryption.  Thus
    nonces are not used to generate a shared key but bring freshness
    to the messages.
  \item {\em \smn}: does not provide any security.  Using this mode, the
      {\em OpenSecureChannel} sub-protocol does not serve much
      purpose but is used for compatibility.
\end{itemize}

\vspace{-1em}
\begin{figure}[htb]
    \centering
    \renewcommand{\smname}{\smseshort}
    \resizebox{.8\linewidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{2.6\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{DiscoreryEndpoint}{}
                \declinst{sess}{S}{}

                \msccomment[-.5]{1.}{cli}
                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \msccomment[-.5]{2.}{cli}
                \mess{\geres, pk(S), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                %\action*{Validates pk(S)}{cli}
                %\nextlevel[2]
                
                \action*{Generates $N_{C}$}{cli}
                \nextlevel[3]

                \msccomment[-.5]{3.}{cli}
                \mess{pk(C), \sm{\oscreq, pk(C), $N_{C}$}{pk(S)}{sk(C)}}{cli}{sess}
                \nextlevel[1]

                %\action*{Validates pk(C) }{sess}
                %\nextlevel[2]

                \action*{Generates $N_{S}$ }{sess}
                \nextlevel[2.5]

                %\ifsmnotnone{%
                %    \action*{$(K_{SC}, KSig_{SC})$ = $P\_hash(N_{S}, N_{C})$ }{sess}
                %    \nextlevel[3.5]
                %}

                \msccomment[-.5]{4.}{cli}
                \mess{\sm{\oscres, $N_{S}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{cli}
                %\nextlevel[1]

                %\ifsmnotnone{%
                %    \action*{$(K_{CS}, KSig_{CS})$ = $P\_hash(N_{C}, N_{S})$ }{cli}
                %    \nextlevel[2]
                %}
            \end{msc}
        \end{postscript}
    }
    \caption{\opcua{} \securechan sub-protocol in mode \smse.}
    \label{fig:secure_channel_se}
\end{figure}
\vspace{-1em}

This protocol is described in Figure~\ref{fig:secure_channel_se}.  In
message 1. $C$ requests information on $S$ with {\em GEReq} meaning
{\em GetEndpointRequest}.  In message 2. $DiscoveryEndpoint$ answers
with the following  informations where {\em GERes} stands for {\em
  GetEndpointResponse}, {\em SP} for {\em Security Policy} and {\em
  UP} for {\em UserPolicy}.  Both {\em SP} and {\em UP} are used for
cryptographic primitive negociations.  In message 3. $C$ sends a nonce
 $N_{C}$ to $S$ with {\em OSReq} standing for {\em
  OpenSecureChannelRequest}.  Finally in message 4. $S$ answers a
nonce $N_{S}$ to $C$ with {\em OSCRes} for {\em
  OpenSecureChannelResponse}, {\em ST} for {\em SecurityToken} (a
unique identifier for the channel) and {\em TTL} for {\em TimeToLive}
(its life-time).  The four terms {\em GEReq, GERes, OSCReq} and {\em
  OSCRes} indicate the purpose of each message of the protocol.  At
the end of this protocol, both $C$ and $S$ derive four keys as follows using the
nonces using a function named $P\_hash$, similar to the one specified
in TLS~\cite{DR08}: $(K_{CS}, KSig_{CS})$ = $P\_hash(N_{C}, N_{S})$
and $(K_{SC}, KSig_{SC})$ = $P\_hash(N_{S}, N_{C})$.

\subsection{Modeling}

Normally, a {\em GetEnpointRequest} would be answered by a list of
session endpoints with possibly different security modes. We suppose
that the client always accepts the security mode proposed.  Client's
and server's certificates have been abstracted as their public keys
(which explains why $pk(C)$ appears twice in message 3.).  Moreover,
thanks to the perfect encryption hypothesis, we can abstract the
cryptographic primitives used.  We consider an intruder whose public
key would be accepted by a legitimate client or server.  Such an
intruder could for instance represent a legitimate device that has
been corrupted through a virus or that is controlled by a malicious
operator.
%Finally, it is said in
%\cite{MLD09} that ``\emph{The establishment of the Secure Channel is
%  mainly used for exchanging special secret information between
%  clients and servers. This secret is used for deriving Symmetric Keys
%  $[...]$}''.  To the best of our knowledge, no more precision is
%given in \cite{MLD09,opcua_part2,opcua_part4,opcua_part6} on which
%cryptographic primitives should be used for such purpose.  Thus we
%chose to model this key derivation using the \DiH mechanisms which
%relies on the commutativity of the exponentiation: $(g^a)^b =
%(g^b)^a$.
In this context, we consider the following security objectives: (i)
the secrecy of the keys obtained by $C$, (ii) the secrecy of the keys obtained
by $S$, (iii) the authentication of $C$ on $N_{C}$ and (iv) the authentication of $S$
on $N_{S}$.

\subsection{Results}\label{sec:secure_channel_res}

We run \proverif on this protocol for of the three security
modes of \opcua{} for each objective proposed.
Results are shown in Table \ref{tab:secure_channel_results}.

\vspace{-1em}
\begin{table}[htb]
    \centering
    %\hspace{-1em}
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua{} Security mode} & \multicolumn{4}{|c|}{Objectives} \\
        \cline{2-5}
                       & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $N_{S}$  & Auth $N_{C}$  \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \sms           & \UNSAFE       & \UNSAFE      & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for textbook {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_channel_results}
\end{table}
\vspace{-2em}

Obviously, as the security mode \smn~does not provide any security,
all objectives can be attacked and as nonces are exchanged in plaintext in
security mode \sms, the keys are leaked.
Moreover, attacks on authentication
in the case of \sms~and \smse~implies the intruder rerouting messages.
Such manipulation differs from replaying a message as it does not
delay the message more than what a legitimate router would do (thus
avoiding replay protections such as timestamps).  Figure
\ref{fig:secure_channel_atk} shows an attack on the authentication of
$C$ using $N_{C}$.  This attack is possible because the standard
\opcua{} protocol does not require explicitly to specify the identity of
the receiver of a message.  Thus it allows the intruder to send to $S$
the signed message $C$ sent to him similarly as the \emph{man-in-the-middle} attack on the
Needham-Schroeder protocol~\cite{Low96}.
%However, these attacks are
%not exploitable in security modes \sms~and \smse~since the secrecy of the keys
%is proven by the tool.  It means that even if an intruder can usurp a
%client when speaking to a server and vice-versa, he will not obtain
%the key derived by the protocol.
%Such property holds thanks to the \DiH key derivation mechanism that allows
%to exchange the nonces without revealing them (sending $g^{N_{C}}$ instead of 
%$N_{C}$).

\vspace{-1em}
\begin{figure}[htb]
    \hspace{-2.25em}
    \renewcommand{\smname}{\smse}
    \resizebox{1.1\columnwidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{5.1\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{I}{}
                \declinst{sess}{S}{}

                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \mess{\geres, pk(I), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                %\action*{Validates pk(I)}{cli}
                %\nextlevel[2]
                
                \action*{Generates $N_{C}$}{cli}
                \nextlevel[3]

                \mess{pk(C), \sm{\oscreq, pk(C), $N_{C}$}{pk(I)}{sk(C)}}{cli}{intruder}
                \nextlevel[2]

                \mess{pk(C), \sm{\oscreq, pk(C), $N_{C}$}{pk(S)}{sk(C)}}{intruder}{sess}
                \nextlevel[1]

                %\action*{Validates pk(C) }{sess}
                %\nextlevel[2]

                %\action*{Generates N$_{S}$ }{sess}
                %\nextlevel[2]

                %\ifsmnotnone{%
                %    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
                %    \nextlevel[3]
                %}

                %\mess{\sm{\oscres, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{intruder}
                %\nextlevel[1.5]
            \end{msc}
        \end{postscript}
    }
    \caption{Attack on $N_{C}$: $I$ usurps $C$ when speaking to $S$.}
    \label{fig:secure_channel_atk}
\end{figure}

\vspace{1em}
\subsection{Fixed version}\label{sec:secure_channel_fix}

We propose a fixed version of the {\em OpenSecureChannel} sub-protocol.
%in Figure \ref{fig:secure_channel_fix_se}.
It consists in explicitly adding the identity of the receiver to the messages
and thus  avoids an intruder rerouting signed messages to usurp hosts as
presented in Section~\ref{sec:secure_channel_res}.
More formally, message 3. and 4. of Figure~\ref{fig:secure_channel_se} are replaced
by:
%\vspace{-15pt}
\arraycolsep=1.4pt
{\small
\begin{flushleft}
    $\begin{array}{lrllll}
        3. & C & \rightarrow & S & : & \text{\sm{\oscreq, {\bf S}, pk(C), $N_{C}$}{pk(S)}{sk(C)}}\\
        4. & S & \rightarrow & C & : & \text{\sm{\oscres, {\bf C}, $N_{S}$, ST, TTL}{pk(C)}{sk(S)}}\\
    \end{array}$
\end{flushleft}
}
%\vspace{-.5em}

Note that instead of adding identity in these messages, one could add the user's
public keys ($pk(C)$ instead of $C$ for instance).
This is one of the classical counter-measures for communication protocols
proposed in \cite{AN96}.
Moreover, the \opcua{} standards~\cite{MLD09,opcua_part2,opcua_part4,opcua_part6}
advise the use of key wrapping~\cite{FLS11}.
Although the use of such mechanism in security mode \sms~remains unclear in the
standard, we take advantage of it in this fixed version to ensure the secrecy of
derived keys in security mode \sms.
More formally, occurrences of $N_{C}$ are replaced by
$\left\{\mbox{$N_{C}$}\right\}_{pk(S)}$ in message 3 and all occurrences of
$N_{S}$ in message 4 by $\left\{\mbox{$N_{S}$}\right\}_{pk(C)}$.
Thus all the messages are signed in security mode \sms{} but only the nonces are
encrypted.
We also use \proverif to check the security of the protocol with both
counter-measures.
The results are presented in Table \ref{tab:secure_channel_fix_results} and
show that both authentication and secrecy are now secure for security modes
\sms~and \smse.
We checked the counter-measures separately and to confirm that both are
required (explicitly specifying the receiver of a message in its signature fixes
attacks found on authentication and key wrapping ensures the secrecy of the keys).

\vspace{-1em}
\begin{table}[htb]
    \centering
    %\hspace{-1em}
    %\resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\opcua{} Security mode} & \multicolumn{4}{|c|}{Objectives} \\
        \cline{2-5}
                       & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $N_{S}$  & Auth $N_{C}$  \\
        \hline
        \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline
        \sms           & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline
        \smseshort     & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline
    \end{tabular}
    %}
    \caption{Results for fixed {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_channel_fix_results}
\end{table}
\vspace{-3em}
