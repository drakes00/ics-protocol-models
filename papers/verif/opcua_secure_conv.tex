%\newcommand{\gereq}{GetEndpointRequest}
%\newcommand{\geres}{GetEndpointResponse}
%\newcommand{\oscreq}{OpenSecureChannelRequest}
%\newcommand{\oscres}{OpenSecureChannelResponse}
\newcommand{\gereq}{GEReq}
\newcommand{\geres}{GERes}
\newcommand{\oscreq}{OSCReq}
\newcommand{\oscres}{OSCRes}

\TODO Possibilit√© d'enlever les tags pour cette section.

The {\em OpenSecureConversation} sub-protocol, aims to authenticate a client and
a server and allow them to generate a shared key for the later communications.
\opcua can be used with three security modes, namely {\em \smn}, {\em Sign} and
{\em \smse}.

\begin{itemize}
    \item \smse: claims to provide secrecy using symetric and
      assymetric encryption and both authentication and integrity
      through digital signatures.  It is described in
      Figure~\ref{fig:secure_conv_se}.

    \item Sign: same as {\em \smse} but without any encryption.  Thus
      nonces are not used to generate a shared key but bring freshness
      to the messages.

    \item \smn: does not provide any security.  Using this security
      mode, the {\em OpenSecureConversation} sub-protocol does not
      serve much purpose but is used for compatibility.
\end{itemize}

\begin{figure}[htb]
    \renewcommand{\smname}{\smseshort}
    \resizebox{\linewidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{2.6\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{DiscoreryEndpoint}{}
                \declinst{sess}{S}{}

                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \mess{\geres, pk(S), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                \action*{Validates pk(S)}{cli}
                \nextlevel[2]
                
                \action*{Generates N$_{C}$}{cli}
                \nextlevel[3]

                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{cli}{sess}
                \nextlevel[1]

                \action*{Validates pk(C) }{sess}
                \nextlevel[2]

                \action*{Generates N$_{S}$ }{sess}
                \nextlevel[2]

                \ifsmnotnone{%
                    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
                    \nextlevel[3.5]
                }

                \mess{\sm{\oscres, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{cli}
                \nextlevel[1]

                \ifsmnotnone{%
                    \action*{$K_{cli}$ = $(g^{N_{S}})^{N_{C}}$}{cli}
                    \nextlevel[2]
                }
            \end{msc}
        \end{postscript}
    }
    \caption{\opcua OpenSecureConversation sub-protocol}
    \label{fig:secure_conv_se}
\end{figure}

\subsection{Modeling}

Normaly, a {\em GetEnpointRequest} would be answered by a list of session
endpoints with possibly different security modes.
For simplicity, we suppose that only one endpoint is answered.
Thus, to ensure completeness of our analysis, we verify all combinations of
security modes (\eg a client configured in {\em \smn} speaking with a server
configured in {\em \smse}, which would not be possible normaly).
This way we can verify if an attacker can exploit the security of a peer as an
oracle to mount an attack against another.
This also shows exactly what th security mode of a host gives him as protection
independantly of the security mode of its peers.
Moreover, thanks to the perfect encryption hypothesis, we can abstract the
security policy messages as we do not differentiate which cryptographic
primitives are used.

Objectives:
\begin{enumerate}
    \item\label{item:sc_sec_cli} Secrecy of $K_{cli}$ obtained by C.
    \item\label{item:sc_sec_srv} Secrecy of $K_{src}$ obtained by S.
    \item\label{item:sc_auth_cli} Authentication on $g^{Nc}$.
    \item\label{item:sc_auth_srv} Authentication on $g^{Ns}$.
\end{enumerate}

\subsection{Results}

We run \proverif on this protocol for each combination of the three security
modes of \opcua for each objective proposed.
Results are shown in Table \ref{tab:secure_conv_results}.

\begin{table}[htb]
    \hspace{-1em}
    \resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \multicolumn{2}{|c}{\opcua Modes} & \multicolumn{4}{|c|}{Objectives} \\
        \hline
        C              & S              & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $g^{N_{S}}$  & Auth $g^{N_{C}}$  \\
        \hline                                                                                                 
        \smn           & \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline                                                                                                 
        \smn           & \sms           & \UNSAFE       & \SAFE         & \UNSAFE           & \SAFE             \\ 
        \hline                                                                                                 
        \smn           & \smseshort     & \UNSAFE       & \SAFE         & \UNSAFE           & \SAFE             \\ 
        \hline                                                                                                 
        \sms           & \smn           & \SAFE         & \UNSAFE       & \SAFE             & \UNSAFE           \\ 
        \hline                                                                                                 
        \sms           & \sms           & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline                                                                                                 
        \sms           & \smseshort     & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline                                                                                                 
        \smseshort     & \smn           & \SAFE         & \UNSAFE       & \SAFE             & \UNSAFE           \\ 
        \hline                                                                                                 
        \smseshort     & \sms           & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline                                                                                                 
        \smseshort     & \smseshort     & \SAFE         & \SAFE         & \UNSAFE           & \UNSAFE           \\ 
        \hline
    \end{tabular}
    }
    \caption{Results for textbook {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_conv_results}
\end{table}

%Exemple d'attaque :
%\begin{figure}[htb]
%    \renewcommand{\smname}{\smse}
%    \resizebox{\columnwidth}{!}{
%        \begin{postscript}
%            \begin{msc}{Secure channel creation}
%                \setlength{\envinstdist}{1.5\envinstdist}
%                \setlength{\instdist}{5.1\instdist}
%                \setlength{\labeldist}{1.5\labeldist}
%
%                \declinst{cli}{C}{}
%                \declinst{intruder}{I}{}
%                \declinst{sess}{S}{}
%
%                \mess{\gereq}{cli}{intruder}
%                \nextlevel[1.5]
%
%                \mess{\geres, pk(I), \smname, SP, UP}{intruder}{cli}
%                \nextlevel[1]
%                
%                \action*{Validates pk(I)}{cli}
%                \nextlevel[2]
%                
%                \action*{Generates N$_{C}$}{cli}
%                \nextlevel[3]
%
%                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(I)}{sk(C)}}{cli}{intruder}
%                \nextlevel[2]
%
%                \mess{pk(C), \sm{\oscreq, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{intruder}{sess}
%                \nextlevel[1]
%
%                \action*{Validates pk(C) }{sess}
%                \nextlevel[2]
%
%                \action*{Generates N$_{S}$ }{sess}
%                \nextlevel[2]
%
%                \ifsmnotnone{%
%                    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
%                    \nextlevel[3]
%                }
%
%                \mess{\sm{\oscres, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{intruder}
%                \nextlevel[1.5]
%            \end{msc}
%        \end{postscript}
%    }
%    \caption{\opcua Secure Conversation \smse}
%\end{figure}

\subsection{Fixed version}

We propose a fixed version of the {\em OpenSecureConversation} sub-protocol in
Figure \ref{fig:secure_conv_fix_se}.
It consists in adding in a message the identity of its reciever.
This avoids an intruder replaying signed messages.

\begin{figure}[htb]
    \hspace{-1em}
    \renewcommand{\smname}{\smseshort}
    \resizebox{1.05\columnwidth}{!}{
        \begin{postscript}
            \begin{msc}{Secure channel creation}
                \setlength{\envinstdist}{1.5\envinstdist}
                \setlength{\instdist}{2.8\instdist}
                \setlength{\labeldist}{1.5\labeldist}

                \declinst{cli}{C}{}
                \declinst{intruder}{DiscoreryEndpoint}{}
                \declinst{sess}{S}{}

                \mess{\gereq}{cli}{intruder}
                \nextlevel[1.5]

                \mess{\geres, pk(S), \smname, SP, UP}{intruder}{cli}
                \nextlevel[1]
                
                \action*{Validates pk(S)}{cli}
                \nextlevel[2]
                
                \action*{Generates N$_{C}$}{cli}
                \nextlevel[3]

                \mess{pk(C), \sm{\oscreq, {\bf S}, pk(C), $g^{N_{C}}$}{pk(S)}{sk(C)}}{cli}{sess}
                \nextlevel[1]

                \action*{Validates pk(C) }{sess}
                \nextlevel[2]

                \action*{Generates N$_{S}$ }{sess}
                \nextlevel[2]

                \ifsmnotnone{%
                    \action*{$K_{srv}$ = $(g^{N_{C}})^{N_{S}}$ }{sess}
                    \nextlevel[3.5]
                }

                \mess{\sm{\oscres, {\bf C}, $g^{N_{S}}$, ST, TTL}{pk(C)}{sk(S)}}{sess}{cli}
                \nextlevel[1]

                \ifsmnotnone{%
                    \action*{$K_{cli}$ = $(g^{N_{S}})^{N_{C}}$}{cli}
                    \nextlevel[2]
                }
            \end{msc}
        \end{postscript}
    }
    \caption{\opcua OpenSecureConversation sub-protocol}
    \label{fig:secure_conv_fix_se}
\end{figure}

We tested this fixed version under the same circumstances than the textbook
version.
Results are presented in Table \ref{tab:secure_conv_fix_results}.

\begin{table}[htb]
    \hspace{-1em}
    \resizebox{1.05\columnwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \multicolumn{2}{|c}{\opcua Modes} & \multicolumn{4}{|c|}{Objectives} \\
        \hline
        C              & S              & Sec $K_{cli}$ & Sec $K_{srv}$ & Auth $g^{N_{S}}$  & Auth $g^{N_{C}}$  \\
        \hline                                                                                                  
        \smn           & \smn           & \UNSAFE       & \UNSAFE       & \UNSAFE           & \UNSAFE           \\ 
        \hline                                                                                                  
        \smn           & \sms           & \UNSAFE       & \SAFE         & \UNSAFE           & \SAFE             \\ 
        \hline                                                                                                  
        \smn           & \smseshort     & \UNSAFE       & \SAFE         & \UNSAFE           & \SAFE             \\ 
        \hline                                                                                                  
        \sms           & \smn           & \SAFE         & \UNSAFE       & \SAFE             & \UNSAFE           \\ 
        \hline                                                                                                  
        \sms           & \sms           & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline                                                                                                  
        \sms           & \smseshort     & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline                                                                                                  
        \smseshort     & \smn           & \SAFE         & \UNSAFE       & \SAFE             & \UNSAFE           \\ 
        \hline                                                                                                           
        \smseshort     & \sms           & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline                                                                                                           
        \smseshort     & \smseshort     & \SAFE         & \SAFE         & \SAFE             & \SAFE             \\ 
        \hline
    \end{tabular}
    }
    \caption{Results for fixed {\em OpenSecureChannel} sub-protocol}
    \label{tab:secure_conv_fix_results}
\end{table}
