In this section, we explain how the the stateful filtering mechanism we propose
works.

\paragraph{Variables:} All variables of present on a server should be known by
filter. Thus a variable represented by a numerical identifier is associated to a server
(associated to a protocol), a data type (\eg uint32 or double) and the path on 
the server to access it (\eg a \modbus address or an \opcua node).
Variables can also have a sequence of dimensions (\eg the length of an array or
the dimensions of a matrix).
Their definition is shown in Listing~\ref{lst:var}.

\begin{lstlisting}[label=lst:var,caption=Variable definition example]
# A <@{\color{Green} \modbus}@> server
Declare Server 1 Protocol Modbus Addr 10.0.0.1 Port 502
<@\vspace{-.8em}@>
# A <@{\color{Green} \modbus}@> coil
Declare Variable 1 Server 1 Type Boolean Addr coils:0x1000
<@\vspace{-.8em}@>
# An <@{\color{Green} \opcua}@> server
Declare Server 2 Protocol OpcUa Addr 10.0.0.2 Port 48010
<@\vspace{-.8em}@>
# An <@{\color{Green} \opcua}@> unsigned integer 5<@{\color{Green} $\times$}@> 10 matrix
Declare Variable 2 Server 2 Type UInt32 Addr numeric:5000 Dims 5 10
\end{lstlisting}

\paragraph{Monitors:} A monitor represents a local copy of a declared variable.
To ensure bounded memory, it only applies to one cell of the variable when
multidimensional.
We use the {\em Index} keyword followed by enough valid array keys to obtain a
scalar value.
Such constraint can be lifted if and only if the size and dimensions of a
variable cannot be modified once set.
The value of a monitor shall be updated when a message containing the value
goes through the filter.
It applies for example to read responses and write requests.
Updates on write requests must be reversible since the request can possibly be
rejected by the server.
Thus the new value shall be stored in a temporary variable until server confirms
the success of the request.
Other services can be used to update monitors depending on the protocols such
as \opcua's publish status.
An example of the definition of monitors is shown in Listing~\ref{lst:mon}.

\begin{lstlisting}[label=lst:mon,caption=Monitor definition example]
# A monitor on a <@{\color{Green} \modbus}@> coil
Declare Monitor 1 Variable 1
<@\vspace{-.8em}@>
# A monitor a cell of an <@{\color{Green} \opcua}@> unsigned integer 5<@{\color{Green} $\times$}@> 10 matrix
Declare Monitor 2 Variable 2 Index 3 4
\end{lstlisting}

\paragraph{Rules:} Finally rules can be set on variables using the previously
declared monitors.
They can target either a whole variable or a subrange when multidimensional.
They take the form of disjunctive normal forms (DNF) which are basically a sum of
product with addition and multiplication being respectively logical OR and AND.
Multiple rules can be expressed in DNF and they have to all be verified to 
authorize a message, thus the set of all rules becomes a conjunctive normal
form.
The predicates involved in the rules are boolean functions taking two arguments.
These functions implement boolean conditions such as equality, integer
relations, etc.
Arguments take the form of constant numbers.
We also introduce two keywords: (i) {\em NewVal} designating the value to be
written in a write request (possibly restricted to a single cell if the rule
targets a multidimensional variable) and (ii) {\em LocalVal} designating a
monitor by its identifier.
A rule can be either an assertion that will block a message when violated or a
warning that will authorize the message but log the violation for a later
decision.
An example of the definition of rules is shown in Listing~\ref{lst:rule}.

\begin{lstlisting}[label=lst:rule,caption=Rule definition example]
# Variable 1 should never been set to its current value
# (<@{\color{Green} \eg}@> opening a currently opened circuit breaker)
Declare Rule Variable 1 Assert NotEqual(NewVal, LocalVal[1])
<@\vspace{-.8em}@>
# The first three rows of variable 2 must remain between 0 and 100.
Declare Rule Variable 2 Range 0-5 0-2 Warning \
    GreaterThan(NewVal,0) AND LessThan(NewVal,100)
\end{lstlisting}

All of our predicate can be verified in $\mathcal{O}(1)$ complexity.
So processing one command only depends on the number of rules.
