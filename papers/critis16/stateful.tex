In this Section, we discuss shortly what it stateful filtering and its
shortcomings.
Stateful filtering consists in keeping track of the value of predertemined
variables of servers.
The filter saves the value of the variable when they go through.
As we said in Section~\ref{sec:intro} this implies the filter to be the single
point of passage of all messages.
This implies that the filter must be hardened to resist against attacks.
It also requires it to run in bounded memory and execution time to not delay
real time message (for instance filters that necessitate sorting) or crash the
filter when processing a memory-worst-case message.
Same applies to evaluation of arithmetic operations which uses a pushdown
automaton which consumes memory depending on the size of the operation.
Thus a long enough message could fill the memory of the filter.
%
Morover, no decision can be taken for a variable if it have not been seen once
before.
For this sake, one might want to use three values logic such as Kleene's
logic~\cite{Kle52}.
This also holds if the server can update variables on his own (such as
temparature, pression, etc) and they are not read frequently enough.
Three values logics introduce a value neither true or false, called
{\em unknown} or {\em irrelevant} and extend classic logic operators to handle
such value.
Thus a default policy is needed when the filter is not able to take a decision.

\paragraph{Attacker model:} We consider an attacker that is able to communicate
with the server through a filter using network.
The intruder has access to the rules configured for the filter.
We also consider the attacker having access to their implementations.
This can be illustrated by an attacker purchasing a copy of the filter and
reverse engineering it.
Finaly we make the hypothesis that the attacker has no physical access to the
filter and cannot for instance power it off.
