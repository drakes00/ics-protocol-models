\documentclass{article}

%\usepackage{fullpage}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage[french]{babel}

\usepackage{authblk}

\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{graphicx}
\usepackage{xstring}

%\usepackage{times}

\usepackage{auto-pst-pdf}
\ifpdf
    \usepackage{todonotes}
    \usepackage{tikz}
    \usetikzlibrary{arrows,automata}
\else
    \usepackage{msc}
\fi

% ========== Don't touch ==========
\makeatletter
    \def\msc@frame{no}
    \def\msc@settitle{}
\makeatother

\newcommand{\dosmnone}[3]{#1}
\newcommand{\dosmsign}[3]{#1, $\left\{\mbox{#1}\right\}_{\mbox{#3}}$}
\newcommand{\dosmsignandencrypt}[3]{$\left\{\mbox{#1}\right\}_{\mbox{#2}}$, $\left\{\mbox{#1}\right\}_{\mbox{#3}}$}

\newcommand{\smn}{None}
\newcommand{\sms}{Sign}
\newcommand{\smse}{SignAndEncrypt}

\newcommand{\sm}{\IfStrEq{\smname}{\smn}{\dosmnone}{\IfStrEq{\smname}{\sms}{\dosmsign}{\dosmsignandencrypt}}}

\newcommand{\ifsmnotnone}[1]{\IfStrEq{\smname}{\smn}{}{#1}}
\newcommand{\smname}{\smn}
% ========== Don't touch ==========

\newcommand{\UNSAFE}{{\color{red!50!black} UNSAFE}}
\newcommand{\SAFE}{{\color{green!50!black} SAFE}}
\newcommand{\proverif}{ProVerif}

\title{Verification formelle de protocoles industriels}

\author[1]{Maxime Puys}
\author[1]{Marie-Laure Potet}
\author[2]{Jean-Louis ?}
\author[3]{Pascal ?}

\affil[1]{
    Univ. Grenoble Alpes, VERIMAG, F-38000 Grenoble, France\\
    CNRS, VERIMAG, F-38000 Grenoble, France
}

\date{}

\begin{document}

\maketitle

%\begin{abstract}
%    aa
%\end{abstract}

\section{Introduction}

Les protocoles sont un ingrédient essentiel des communications réseaux de notre époque.
Ces communications pouvant être attaquées soit en espionnant le trafic, soit en le modifiant,
il apparait depuis plusieurs décennies que la preuve formelle de la sécurité de ces protocoles
est un enjeu majeur.
Un exemple connu étant {\em mi.TLS} \cite{BFKPS13}, une implémentation prouvée du protocole TLS \cite{DR08}
servant par exemple au paiement en ligne.
Cependant, les protocoles de communication des systèmes industriels servant à envoyer des commandes
et recevoir des informations n'ont jamais été vérifiés de cette façon.
Ces protocoles régissant parfois jusqu'à des centrales nucléaires, des barrages ou la distribution d'énergie,
il est vital de s'assurer de leur sécurité.

Les traveaux d'analyse de protocoles hors du cadre industriel ont commencé avec la contribution de
G. Lowe \cite{Low96}, brisant le protocole {\em Needham-Schoeder} en 1995.
Depuis, les outils d'analyse et les travaux de modélisation se sont multipliés.
Ces outils reposent sur des approches théoriques variées telles que la réécriture,
la résolution de contrainte, les clauses de Horn ou les {\em SAT-solvers}.
Ces outils considèrent un intrus dit de Dolev-Yao \cite{DY81} qui contrôle le réseau,
espionne, stoppe, forge, modifie, entrelace ou rejoue des messages en utilisant la connaissance
des messages qu'ils appris précédemment.
En jouant en parallèle plusieurs sessions avec les différents rôles du protocole,
l'intrus tente de violer des propriétés telles que l'{\em autentification} et le {\em secret}.
La première propriété signifie qu'un participant est conviancu qu'il parle avec un autre.
Le secret assure qu'un agent non autorisé (y compris l'intrus) n'accède pas au message désigné.
Enfin, les outils se basent sur l'hypothèse du chiffrement parfait, selon laquelle
il n'est pas possible de déchiffrer un message sans la chef de chiffrement ou d'usurper une signature.

En particulier, \proverif{} \cite{Bla01,PROVERIF14_manual}, développé par B. Blanchet et al. analyse un protocole écrit
soit en clauses de Horn soit dans un sous ensemble du Pi-Calcul pour un nombre non borné
de sessions.
Via des techniques de sur-approximation, il est capable de prouver la sécurité d'un protocole
mais les attaques qu'il trouve peuvent être des faux-positifs.
Lorsqu'une attaque est trouvée, l'outil reconstruit une trace montrant sa réalisation.

\section{Le protocol OPC-UA}

OPC-UA \cite{MLD09} est un protocole de communication qui devient un standard dans le milieu industriel.
Ce nouveau protocole très complexe de part la diversité des données qu'il peut transférer
se divise en plusieurs couches. 
Parmi elles, la couche {\em Secure Conversation} est en charge de la sécurité en termes d'authentification,
de contrôle d'accès, d'intégrité et de chiffrement.
Trois niveaux de sécurité peuvent être utilisés suivant la configuration des clients et des serveurs.

Plusieurs sous-protocoles atomiques interviennent dans cette couche :
\begin{enumerate}
    \item Le sous-protocole {\em Secure Channel Establishment} se sert des
        clefs assymétriques des participants pour établir une clef symétrique partagée.
    \item Ensuite, le sous-protocole {\em Session Establishment} utilise la clef symétrique partagée
        par les participants pour que le client envoie ses identifiants au serveur.
    \item Le client peut alors envoyer des requêtes et le serveur les réponses associées
        en utilisant la clef symétrique partagée.
    \item Enfin, le sous-protocole {\em Secure Conversation Closing} clot la session et le {\em Secure Channel}.
\end{enumerate}

\section{Travaux de recherche}

Nous souhaitons tester formellement la sécurité d'OPC-UA à l'aide d'outils de vérification de protocoles.
Une attaque pouvant être découverte pourrait être la compromission de la clef symétrique partagée
(qui révèlerait le contenu des communication).
D'autre part, un intrus pourrait se faire passer pour le serveur aux yeux du client ou beaucoup plus grave, se faire passer
pour le client aux yeux du serveur.
Ce scénario gravissime autoriserait l'intrus à lancer des commandes ayant un réel impact sur le monde extérieur
pouvant par exemple égaler les conséquenses du virus Stuxnet en Iran \cite{Lan11}.

Afin de découvrir des attaques ou de prouver formellement la sécurité du protocole, nous cherchons tout d'abord à l'exprimer
sous forme de diagrammess de séquence.
La figure \ref{fig:opcua_diagram} montre par exemple une représentation du sous-protocole {\em Secure Channel Establishment}.

\begin{figure}[htb]
    \input{opcua_secure_channel}
    \caption{Diagramme de séquence pour OPC-UA}
    \label{fig:opcua_diagram}
\end{figure}
    
%\begin{figure}[htb]
%    \lstinputlisting[language=caml]{opcua_proverif.pv}
%    \caption{Exemple de modélisation \proverif{}}
%    \label{fig:opcua_proverif}
%\end{figure}

A partir de représentations, nous pouvons modéliser le rôle de chaque agent dans le langage de l'outil de vérification.
L'outil nous répondra alors soit que le protocole est sûre pour les propriétés que nous avons exprimé,
soit par une attaque contre l'une des propriétés.

\section{Conclusion}

Les défis de ce type d'approche sont principalement la difficulté de modéliser le protocole en captant les propriétés
de sécurité qu'il revendique.
L'outil pouvant produire des faux positifs, il faut également comprendre le attaques trouvée et si elles sont fausses,
changer la modélisation pour qu'elles n'apparaissent plus.
Certains outils permettent également à l'utilisateur d'ajouter des théories equationelles afin d'augmenter
le pouvoir de l'intrus.
Il également possible de modéliser des propriétés de sécurité plus complexes telles que la non-répudiation
(impossibilité de nier l'envoie ou la réception d'un message) ou l'intégrité du flux (vérifier que les messages
reçu par un participant sont exactement ceux envoyés par un autre en tenant compte de l'ordre).

\section{Auteurs}

Biographie ... ?

\bibliographystyle{plain}
\bibliography{phdBiblio}

\end{document}
