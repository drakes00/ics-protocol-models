\documentclass{beamer}

\usepackage[T1]{fontenc}
\usepackage{inputenc}

\usepackage{amsmath}
\usepackage{listings}
\lstset{
  basicstyle=\footnotesize,
  language=Caml,
  showstringspaces=false,
}


\usetheme{Boadilla}
\usecolortheme{dolphin}
\useoutertheme{infolines}


\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor%~~\beamer@ifempty{\insertshortinstitute}{}{(\insertshortinstitute)}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}


\newcommand{\TODO}{{\color{red}\bf [TODO]}}
\definecolor{light-gray}{gray}{0.75}


\title{Architecture and internal communations}
\author{Nicolas Kox and Maxime Puys}
\date{\today}


\begin{document}

\begin{frame}
    \maketitle
\end{frame}



\begin{frame}
\frametitle{Content}
\tableofcontents
\end{frame}


\section{SSH steps}


\begin{frame}
\frametitle{Content}
\tableofcontents[currentsection]
\end{frame}





\subsection{Handshake}


\begin{frame}
\frametitle{Content}
\tableofcontents[currentsubsection]
\end{frame}




\begin{frame}
\frametitle{Hello}

Server listen for a client connection (TCP)\\
On connection, server and client send their protocol version\\
eg. SSH2.0-OpenSSH-6.7\\
\vspace{10 mm}

Directly after, key exchange starts

\end{frame} 



\begin{frame}
\frametitle{Algorithm exchange}
Each party sends a kexinit message to the other\\
This message contains various informations :

\begin{itemize}
\item a cookie (random bytes)
\item key exchange algorithms, including hash
\item signature algorithm
\item encryption algorithms
\item MAC algorithms
\item compression, languages,

\end{itemize}

Two a encryption and MAC algorithms are chosen : one from client to server, and one from server to client\\
In general the same algorithms are chosen for both direction

\end{frame} 
      


\begin{frame}
\frametitle{Key derivation}


Use of DH or ECDH to exchange a private key K\\
Handshake messages are hashed to a digest H\\
The first handshake hash also serves as session identifier\\

\vspace{8mm}
6 values are extracted :
\begin{itemize}
\item 2 symmetric keys
\item 2 Initialization Vectors
\item 2 MAC keys
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Finalization}
On completion, each party sends a NEWKEYS message\\
This message only contains a byte equal to 21\\

\vspace{8mm}
After this messages, all exchanges are encrypted

\end{frame}



\begin{frame}
\frametitle{Module behavior}

The module cannot impersonate SSH server.\\
Two possibilities :
\begin{itemize}
\item the module relays SSH connections : not satisfying since exchanges cannot be decoded
\item the module serves as SSH server on a side, and as SSH client on the other
\end{itemize}


\end{frame}



\begin{frame}
\frametitle{Constraints}
Second case needs additional configuration :

\begin{itemize}
\item Initial client must have a copy of module's server key
\item Module must have a copy of destination server key
\end{itemize}

Under these conditions, two handshakes can occur in parallel\\
Traffic is decrypted and analyzed inside module\\
Traffic is still encrypted outside module
\end{frame}





\subsection{Authentication}

\begin{frame}
\frametitle{Content}
\tableofcontents[currentsubsection]
\end{frame}


\begin{frame}
\frametitle{Authentication methods}
RFCs define 5 authentication methods :
\begin{itemize}
\item none : only based on user name
\item password : based on username and password
\item keyboard-interactive : based on a series of question-answer between server an client
\item publickey : user proves that he owns a private key
\item hostbased : based on the presence of a private key on client host
\end{itemize}

A server may require multiple authentication factors

\end{frame}



\begin{frame}
\frametitle{Message exchange}
The authentication begins with a client request for service ``user-auth''\\
Server answers a service success message, or close connection\\

\vspace{8mm}

Client then sends a userauth request containing method and associated data\\
When authentication succeeds, server send back a userauth success message\\
Otherwise it sends back an auserauth failure message\\

\vspace{8mm}

Failure message contains accepted authentication methods\\
When multiple authentications are required, a boolean indicates a partial success

\end{frame}



\begin{frame}
\frametitle{Module behavior}

Module CANNOT authenticate user :\\
Credentials must be transfered to destination host for verification

\vspace{8mm}
Module should use same method and credentials as client\\
It may also add an authentication method, eg. hostbased, using its own credentials

\end{frame}



\subsection{Channel mechanism}

\begin{frame}
\frametitle{Content}
\tableofcontents[currentsubsection]
\end{frame}


\begin{frame}
\frametitle{Channel types}
Channels provides SSH features\\
They should be opened only after client authentication\\

\vspace{8mm}
Channel types :
\begin{itemize}
\item session : most SSH functionalities
\item x11 : open a X11 session on server
\item forwarded-tcpip : forward to a distant port
\item direct-tcpip : forward to a local port
\end{itemize}

Channel are identified at each end by a number
\end{frame}



\begin{frame}
\frametitle{Channel requests}
Once a channel is opened several requests can be adressed\\
Most important are the following :
\begin{itemize}
\item shell : ask for a remote shell
\item tty : ask for a remote tty, shell part is run on the other side
\item exec : ask for a remote command execution
\item subsystem : scp, sftp, netconf...
\item env : sets the value of a environment variable
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Data transfert}
When a channel is established, data can be send trough it\\
Data are interpreted depending which service is running (shell, subsystem...)

\vspace{8mm}

Each sides allocates a ``window'', corresponding to the amount of data it can receive
When whole window have been used, peer must wait for a window change before sending more data

\end{frame}




\begin{frame}
\frametitle{Module behavior}
Module can act in different ways :

\begin{itemize}
\item Synchronously : each response correspond to the real response from distant server
\item Asynchronously : module answers successfully to each request, while transfering them
\end{itemize}

In asynchronous mode, errors may be delayed

\end{frame}



\subsection{Subsystems}

\begin{frame}
\frametitle{Content}
\tableofcontents[currentsubsection]
\end{frame}


\begin{frame}
\frametitle{Principles}


Use channel data transfert : SSH serves as session layer\\
Have their own language, independant from SSH\\
Can be seen as a shell, with  a limited set of commands

\vspace{8mm}
Example : sftp, scp, netconf\\
Possibility to add custom subsystem whenever server understand them

\end{frame}


\begin{frame}
\frametitle{SFTP}

SFTP allow remote file manipulations\\
Resquests are given an identifier\\

Responses are sent asynchronously : correspondance between requests and responses is done using identifiers


\end{frame}


\begin{frame}
\frametitle{Module behavior}


For a remote shell, data are transfered as they are typed\\
It should be simplier to bufferize command before analysing it

\vspace{8mm}
Still need to analyze how sftp command are transmitted\\
Best module behavior will depends on prtocol specificities


\end{frame}









\section{Verifications}

\begin{frame}
\frametitle{Content}
\tableofcontents[currentsection]
\end{frame}



\begin{frame}
    \frametitle{Verifications levels}

    \begin{itemize}
        \item OpenSSH: Check if crypto if OK.
        \vfill
        \item SFTP: Check for attacks exploiting the SFTP commands.
        \vfill
        \item SCADA: AD-HOC verifications.
    \end{itemize}
\end{frame}

\subsection{OpenSSH level}

\begin{frame}
    \frametitle{OpenSSH level}

    \begin{block}{Environment variables}
    	It is possible through SSH to ask the shell for its environment (encoding, language, ...).\\
    	Can be a source of information for an adversary.
    \end{block}
	\vfill
	\begin{block}{Mitigation}
		Whitelist the variables we a willing to answer.
	\end{block}	
    \vfill
    \begin{block}{Set new variables}
        Is it possible through to modify environment variables or create new ?
    \end{block}
\end{frame}

\subsection{SFTP level}

\begin{frame}
    \frametitle{OpenSSH level}

    \begin{block}{Environment variables}
    	It is possible through SSH to ask the shell for its environment (encoding, language, ...).\\
    	Can be a source of information for an adversary.
    \end{block}
	\vfill
	\begin{block}{Mitigation}
		Whitelist the variables we a willing to answer.
	\end{block}	
\end{frame}

\begin{frame}
    \frametitle{SFTP level}

    \begin{block}{Code injection}
        Adversary manages to make the application execute arbitrary code.\\
        Possible through buffer overflows, XSS, SQL injections, ...\\
        Code injected has the same privileges than the vulnerable application.
    \end{block}
    \vfill
    \begin{block}{Example}
	    Shellcodes, scripts, SQL commands...\\
    	Limited by the functionality of the injected language itself.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{SFTP level}

    \begin{block}{Command injection}
        Adversary manages to make the application execute artitrary (shell) command.\\
        Code injected has the same privileges than the vulnerable application.
    \end{block}
    \vfill
    \begin{block}{Example}
        exec "useradd {\bf toto; rm -rf /}"\\
        Not limited by a language {\bf BUT} limited by installed software.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Command injection - Example}

    \begin{block}{ShellShock - CVE-2014-6271 (2014-09-14)}
        Possible due to a lack of security in Bash parsing of commands.\\
        Allows to remotly execute arbitrary shell commands following function definitions.
    \end{block}
    \vfill
    \begin{block}{Example}
        env x='() \{ :;\}; {\bf echo "pwnd"}' bash -c "true"
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Command injection - Example}
    \begin{block}{How about SFTP ?}
        Vulnerabilities are located in the client or server implementation (e.g.: WinSCP (CVE-2006-3015) or prosftpd (CVE-2010-4221 - overflow exploitation) rather than in the protocol itself.
    \end{block}
    \vfill
    \begin{block}{Example}
    	\begin{itemize}
            \item Filenames with semicolons: put "ScadaConfigFile.cfg{\bf ;rm -rf /}".
            \item Filenames with ../: put "{\bf ../../}ScadaConfigFile.cfg".
        \end{itemize}
    \end{block}
\end{frame}

\subsection{SCADA level}

\begin{frame}
    \frametitle{SCADA level}
    
    \begin{block}{Filter}
    	A {\bf filter} is a list of {\bf rules} to be matched.
    \end{block}
    \vfill
    \begin{block}{Question}
        To be {\bf rejected}, does a packet need to match/break {\bf one} rule (blacklist) or {\bf all} (whitelist) ?\\
    	\medskip
    	Thus, do we describe all accepted behaviours and then deny everything else ? A normal paquet can be accepted quicker.\\
    	\medskip
    	Or do we describe all rejected behaviours and then allow everything else ? A malicious packet is rejected quicker.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{SCADA level}
    
    Most of the packets should be normal.
    \vfill
    Then, for better avarage response time, we may want to facilitate normal paquets.
    \medskip
    \begin{block}{Aka.}
    	Define accepted behavious.\\
    	Then deny everything else.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{SCADA level - rules types}
    
    3 types of rules:
    \vfill
    \begin{itemize}
    	\item {\bf Stateless rules}: Independant of the current state of the SCADA.
    	\vfill
    	\item {\bf Stateful rules}: The filter need a {\bf representation} of the current state of the SCADA.
    	\vfill
    	\item {\bf Interactive rules}: The rule can't be verified in bounded time or space. A proof needs to be joint with the paquet.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Stateless rules}
    
    Examples:
    \vfill
    \begin{itemize}
    	\item Field {\bf [Sender = ATOS]} is in the packet.
    	\vfill
    	\item A static message is rejected, we keep its hash in a blacklist. {\bf Rule: The packet's hash is not blacklisted.}
    	\vfill
    	\item In the command: SET\_TEMPERATURE n, check that $n \in [500, 2000]$.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Stateful rules}
    
    Example:
    \vfill
    The filter accept a packet with SET\_TEMPERATURE 700, it remebers that $CurTemp = 700$.
    \vfill
    Then the filter sees another packet with SET\_TEMPRATURE n, it checks that $|n-CurTemp| < \delta$.
\end{frame}

\begin{frame}
    \frametitle{Interactive rules}
    
    Example:
    \vfill
    \begin{block}{Piano deliveryman}
    	Alice wants to move a piano from a room to another and asks Bob if it is feasible (fits through the doors, ...).\\
    	It is realy difficult for Bob to check every possible moves for the piano.\\
    	Bob asks Alice to exhibit a list of moves for the piano.\\
    	It is easy for Bob to verify the moves Alice provided.
    \end{block}
\end{frame}

\end{document}
