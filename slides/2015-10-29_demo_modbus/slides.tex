\documentclass{beamer}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage[french]{babel}

\usepackage{amsmath}
\usepackage{listings}
\lstset{
  basicstyle=\footnotesize,
  language=Caml,
  showstringspaces=false,
  escapeinside={<@}{@>},
  columns=flexible,
}


\usetheme{Boadilla}
\usecolortheme{dolphin}
\useoutertheme{infolines}


\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor%~~\beamer@ifempty{\insertshortinstitute}{}{(\insertshortinstitute)}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}


\newcommand{\TODO}{{\color{red}\bf [TODO]}}
\graphicspath{ {assets/} }


\title{Démonstration MODBUS}
\author[M Puys \and M-L Potet \and J-L Roch]{Maxime Puys \and Marie-Laure Potet \and Jean-Louis Roch}
\date{\today}


\begin{document}

\begin{frame}
    \maketitle
\end{frame}

\begin{frame}
    \frametitle{Objectifs}

    Les objectifs de cette démonstration sont :
    \begin{itemize}
        \item De présenter les capacités des filtres métiers,
        \item TODO,
        \item Et montrer comment l'ensemble du prototype ARAMIS peut filtrer des communications MODBUS.
    \end{itemize}
\end{frame}

\section{Filtres sur la déclaration des variables}

\begin{frame}
    \frametitle{Sommaire}

    \tableofcontents[currentsection]
\end{frame}

\begin{frame}
    \frametitle{Filtres sur la déclaration des variables 1/5}

    \begin{block}{Idée}
        Créer une {\em liste blanche} des variables connues par le filtre et n'autoriser que le traffic les concernant.\\
        Il sera alors possible d'affiner le filtrage en implémentant un contrôle d'accès pour :
        \begin{itemize}
            \item Désigner les clients qui peuvent accéder à chaque variable,
            \item Désigner quel client le serveur peut notifier lors d'un changement de valeur.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Filtres sur la déclaration des variables 2/5}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}
<@{\color{red} BEGIN}@> VAR_DECL 127.0.0.1:5020 ACCEPT_FROM 127.0.0.0/24
    # Tr1
    co[0x0000] 1 boolean RW ACCEPT_FROM 127.0.0.1
    co[0x0001] 1 boolean RW ACCEPT_FROM 127.0.0.1
    co[0x0002] 1 boolean RW ACCEPT_FROM 127.0.0.1
    di[0x0000] 1 boolean RO
    di[0x0001] 1 boolean RO
    di[0x0002] 1 boolean RO
    ho[0x0000] 1 short   RW ACCEPT_FROM 127.0.0.1
<@{\color{red} END}@>
        \end{lstlisting}
    \end{exampleblock}
    \vfill
    Un bloc délimité par les mots clefs {\color{red} BEGIN} et {\color{red} END}.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Filtres sur la déclaration des variables 3/5}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}
BEGIN VAR_DECL <@{\color{red} 127.0.0.1:5020}@> ACCEPT_FROM 127.0.0.0/24
    # Tr1
    co[0x0000] 1 boolean RW ACCEPT_FROM 127.0.0.1
    co[0x0001] 1 boolean RW ACCEPT_FROM 127.0.0.1
    co[0x0002] 1 boolean RW ACCEPT_FROM 127.0.0.1
    di[0x0000] 1 boolean RO
    di[0x0001] 1 boolean RO
    di[0x0002] 1 boolean RO
    ho[0x0000] 1 short   RW ACCEPT_FROM 127.0.0.1
END
        \end{lstlisting}
    \end{exampleblock}
    \vfill
    Chaque bloc de variable est associé à un serveur.\\
    Note: la description IP/Port sera remplacée par un numéro de cannal.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Filtres sur la déclaration des variables 4/5}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}
BEGIN VAR_DECL 127.0.0.1:5020 ACCEPT_FROM 127.0.0.0/24
    # Tr1
    <@{\color{red} co[0x0000] 1 boolean RW}@> ACCEPT_FROM 127.0.0.1
    co[0x0001] 1 boolean RW ACCEPT_FROM 127.0.0.1
    co[0x0002] 1 boolean RW ACCEPT_FROM 127.0.0.1
    di[0x0000] 1 boolean RO
    di[0x0001] 1 boolean RO
    di[0x0002] 1 boolean RO
    ho[0x0000] 1 short   RW ACCEPT_FROM 127.0.0.1
END
        \end{lstlisting}
    \end{exampleblock}
    \vfill
    Chaque variable est décrite par un identifiant, un taille (pour les tableaux), un type et des permissions.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Filtres sur la déclaration des variables 5/5}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}
BEGIN VAR_DECL 127.0.0.1:5020 <@{\color{red}ACCEPT\_FROM 127.0.0.0/24}@>
    # Tr1
    co[0x0000] 1 boolean RW <@{\color{red}ACCEPT\_FROM 127.0.0.1}@>
    co[0x0001] 1 boolean RW ACCEPT_FROM 127.0.0.1
    co[0x0002] 1 boolean RW ACCEPT_FROM 127.0.0.1
    di[0x0000] 1 boolean RO
    di[0x0001] 1 boolean RO
    di[0x0002] 1 boolean RO
    ho[0x0000] 1 short   RW ACCEPT_FROM 127.0.0.1
END
        \end{lstlisting}
    \end{exampleblock}
    \vfill
    Enfin la définition des droits d'accès peut se faire au niveau du bloc puis être redéfinie variable par variable.
\end{frame}

\section{Filtres cinématiques}

\begin{frame}
    \frametitle{Sommaire}

    \tableofcontents[currentsection]
\end{frame}

\begin{frame}
    \frametitle{Filtres cinématiques 1/4}

    \begin{block}{Idée}
        Créer une {\em liste noire} des états interdits par le filtre et bloquer le traffic les concernant.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Filtres cinématiques 2/4}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}
BEGIN CONTEXT 127.0.0.1:5020
    # Case 3_2_3
    <@{\color{red} co[0x0000] == False}@> PREVENT co[0x0000] := False
    co[0x0001] == False PREVENT co[0x0001] := False
    co[0x0010] == False PREVENT co[0x0010] := False
    co[0x0011] == False PREVENT co[0x0011] := False
    co[0x0020] == False PREVENT co[0x0020] := False
    co[0x0021] == False PREVENT co[0x0021] := False
    co[0x0030] == False PREVENT co[0x0030] := False
    co[0x0040] == False PREVENT co[0x0040] := False
END
        \end{lstlisting}
    \end{exampleblock}
    \vfill
    Les filtres à état possèdent une partie gauche qui constitue une garde.\\
    La valeur de toutes les variables apparaissant en partie gauche d'une règle sera mémorisée par le filtre.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Filtres cinématiques 3/4}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}
BEGIN CONTEXT 127.0.0.1:5020
    # Case 3_2_3
    co[0x0000] == False PREVENT <@{\color{red} co[0x0000] := False}@>
    co[0x0001] == False PREVENT co[0x0001] := False
    co[0x0010] == False PREVENT co[0x0010] := False
    co[0x0011] == False PREVENT co[0x0011] := False
    co[0x0020] == False PREVENT co[0x0020] := False
    co[0x0021] == False PREVENT co[0x0021] := False
    co[0x0030] == False PREVENT co[0x0030] := False
    co[0x0040] == False PREVENT co[0x0040] := False
END
        \end{lstlisting}
    \end{exampleblock}
    \vfill
    Lorsque le message spécifié en partie droite arrive au filtre,
    si l'état correspond à la partie gauche alors le paquet est bloqué.\\
\end{frame}

\begin{frame}[fragile]
    \frametitle{Filtres cinématiques 4/4}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}
BEGIN CONTEXT 127.0.0.1:5020
    # Case 3_2_3
    co[0x0000] == False PREVENT co[0x0000] := False
    co[0x0001] == False PREVENT co[0x0001] := False
    co[0x0010] == False PREVENT co[0x0010] := False
    co[0x0011] == False PREVENT co[0x0011] := False
    co[0x0020] == False PREVENT co[0x0020] := False
    co[0x0021] == False PREVENT co[0x0021] := False
    co[0x0030] == False PREVENT co[0x0030] := False
    co[0x0040] == False PREVENT co[0x0040] := False
END
        \end{lstlisting}
    \end{exampleblock}
    \vfill
    Par exemple ici, si une variable a la valeur {\sf False}, on ne peut pas lui assigner
    la valeur {\sf False} à nouveau.\\
    Plusieurs valeurs peuvent apparaîtrent en partie gauche.
\end{frame}

\begin{frame}
    \frametitle{Conclusion}

    On pourra retenir que :
    \vfill
    \begin{itemize}
        \item Les filtres métiers sont génériques (ne dépendent pas du protocole métier).
            \vfill
        \item Ils sont testés pour MODBUS et respectent donc les exigences E\_FCT.10 et E\_FCT.17.
            \vfill
        \item De façon générale, les filtres couvrent actuellement les exigences
            E\_FCT.41, E\_FCT.42, E\_FCT.45, E\_FCT.54, E\_FCT.55 et E\_FCT.56.
            \vfill
        \item Ils ont été testés avec succès sur les scénarios
            0\_1, 0\_2, 3\_1\_1, 3\_1\_2, 3\_2\_2, 3\_2\_3, 3\_2\_4 (7 scénarios)
            et sont en phase de test sur les scénarios 3\_2\_1 et 3\_2\_7 (2 scénarios).
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}

    Pistes pour la suite du projet :
    \vfill
    \begin{itemize}
        \item Expérimenter les scénarios testés en OPC-UA pour valider la généricité des filtres.
            \vfill
        \item Tester les filtres vis à vis de plusieurs serveurs et plusieurs clients.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}

    \begin{center}
        Merci de votre attention
    \end{center}
\end{frame}

\end{document}
